<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RxJava一点思考</title>
      <link href="/2021/02/25/A101/"/>
      <url>/2021/02/25/A101/</url>
      <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>RxJava曾在Android开发中广为流行，一时间Github充斥上打着MVP+RxJava+Retrofit+OkHttp招牌的demo项目。</p><p><br>相信很多人也同我一样看过扔物线<a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>,如获至宝。</p><p><br>我们学习RxJava范式，学习观察者模式，学习背压，学习各种操作符。但，我始终有一个迷惑：<strong><em>RxJava到底是什么场景使用</em></strong>。</p><p><br>目前，RxJava3已经发布，学习热潮已经褪却，听到不少项目甚至开始移除RxJava。我始终难以忘怀初遇RxJava时候那一股激动到无法言表的心情。</p><p><br>此文仅作我对于RxJava一点理解，并不是教程。</p><h2 id="啥是RxJava"><a href="#啥是RxJava" class="headerlink" title="啥是RxJava?"></a>啥是RxJava?</h2><p>引用官网的话：</p><blockquote><p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.</p><p><br>RxJava 是一个在Java虚拟机对于响应式扩展：一个使用<strong><em>可观察序列</em></strong> 来 组织 <strong>*异步和基于事件</strong>编程 的库。</p></blockquote><p>最关键的俩个词<strong><em>asynchronous(:异步的)</em></strong>,<strong><em>event-based(:基于事件的)</em></strong><br>扔物线对于RxJava的理解是”异步”,这是没错的。</p><p><br>但在RxJava2引入了Flowable背压之后，更准确的一个词是<span color="red"><strong><em>数据流转</em></strong></span>。即数据的流动和转化。</p><ul><li>生产者生产数据，消费者消费数据；</li><li>生产-&gt;消费，途径各种线程切换就是流动；</li><li>各类操作符，数据从A-&gt;B就是转换。<br><p><a id="more"></a>无论RxJava中间的操作符如何转化，唯一不变的是：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source</span><br><span class="line">  .operator1()</span><br><span class="line">  .operator2()</span><br><span class="line">  .operator3()</span><br><span class="line">  .subscribe(consumer)</span><br></pre></td></tr></table></figure><p>数据总是从source产生并流向consumer，这种流动可以是单次的(Observable)，也可以是水流一样连续的(Flowable)。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>数据总是从source产生并流向consumer，这种流动可以是单次的(Observable)，也可以是水流一样连续的(Flowable)。</p></blockquote><p>现在，将所有基于RxJava的库忘记。仅凭这一句话，我们能应用到什么场景呢?</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>我脑中始终忘不了的是<strong><em>接口</em></strong>一个词。</p><p><br>我曾从事SDK开发。SDK的接口一直是让我头疼的问题。类似于View#setOnClickListener。工程中往往有大量的接口给客户做使用，我们要写很多很多add/remove/set Listener方法。<br>有了RxJava，一切变的不一样了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Observable</span><br><span class="line">sdk.lifecycle()     # 获取生命周期观察</span><br><span class="line">    .operatorXXX()  # 对生命周期做对应处理</span><br><span class="line">    .subscribe(consumer) # 回调到app的观察器</span><br><span class="line"></span><br><span class="line"># Flowable</span><br><span class="line">sdk.image()         # 获取图像数据流</span><br><span class="line">    .operatorXXX()  # 做图像转化/转换等后处理</span><br><span class="line">    .subscribe(saver) # 存图像</span><br></pre></td></tr></table></figure></p><h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>我们也很容易想到Glide的链式调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide</span><br><span class="line">  .with(myFragment)</span><br><span class="line">  .load(url)</span><br><span class="line">  .centerCrop()</span><br><span class="line">  .placeholder(R.drawable.loading_spinner)</span><br><span class="line">  .into(myImageView)</span><br></pre></td></tr></table></figure></p><p>Glide将url(Source)对应的数据注入到imageView(consumer)中。这涉及了数据下载/缓存/格式处理/转换，Glide帮我们自动忽略了实现细节。<br>假如我们使用RxJava，那么流程可能是这样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Dispose d = RxGlide</span><br><span class="line">    .operatorLoad(url)</span><br><span class="line">    .operatorUrlDownload()</span><br><span class="line">    .operatorImage2Bitmap()</span><br><span class="line">    .subscribe(</span><br><span class="line">        <span class="keyword">new</span> BitmapConsumer(ImageView,R.drawable.loading_spinner)&#123;</span><br><span class="line">            <span class="keyword">void</span> onSubscibe&#123;</span><br><span class="line">                ImageView.setDrawable(R.drawable.loading_spinner)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">void</span> onNext&#123;</span><br><span class="line">                # process显示</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">void</span> onCompolate&#123;</span><br><span class="line">                ImageView.setBitmap(bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 中断</span><br><span class="line">    d.dispose();</span><br></pre></td></tr></table></figure></p><h3 id="数据流处理"><a href="#数据流处理" class="headerlink" title="数据流处理"></a>数据流处理</h3><p>RxJava2中引入的Flowable使处理数据流成为可能。<br>谈及数据流我第一个印象就是Android的图像(Image)。从Camera产生到MediaCodec编码到MediaMuxer保存。一些视频合成场景也是类似。我们有大量数据产生，通过RxJava的背压，可以选择这些数据是丢掉/还是缓存/还是保留最新。<br>举个例子：Image -&gt; MediaCodec<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Image&gt; cameraFlowable = Flowable.create(emitter,BUFFER); #指定背压模式</span><br><span class="line">cameraFlowable</span><br><span class="line">    .operatorToNV21()   # 图像格式转化</span><br><span class="line">    .subscribeOn(IO)    # 指定线程</span><br><span class="line">    .subscribe(MediaCodecConsumer); # 交给消费者处理</span><br></pre></td></tr></table></figure></p><h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>在github输入<code>in:desc RxJava</code>，按照星星数排序。<a href="https://github.com/search?o=desc&amp;q=in%3Adesc+RxJava&amp;s=stars&amp;type=Repositories" target="_blank" rel="noopener">点这里</a></p><p><br>我们选择几个不同领域的库来简单分析一下他们基于RxJava扩展了哪些能力。</p><h3 id="okhttp-OkGo-⭐10-2k"><a href="#okhttp-OkGo-⭐10-2k" class="headerlink" title="okhttp-OkGo ⭐10.2k"></a><a href="https://github.com/jeasonlzy/okhttp-OkGo" target="_blank" rel="noopener">okhttp-OkGo</a> ⭐10.2k</h3><blockquote><p>网络请求</p></blockquote><p></p><p><br>使用RxJava的网络请求库其实还有很多。</p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android JNI 坑</title>
      <link href="/2020/03/01/A100/"/>
      <url>/2020/03/01/A100/</url>
      <content type="html"><![CDATA[<h2 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h2><p>本章节主要用来收集Android JNI开发中遇到的一些问题。</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="官方提示建议"><a href="#官方提示建议" class="headerlink" title="官方提示建议"></a>官方提示建议</h3><p>首先是官方建议文档，可以先看一下，发现实际还是很有帮助的。</p><p><a href="http://developer.android.com/training/articles/perf-jni.html" target="_blank" rel="noopener">JNI 提示  |  Android NDK  |  Android Developers</a></p><h3 id="频繁NewByteArray-创建byte-数据"><a href="#频繁NewByteArray-创建byte-数据" class="headerlink" title="频繁NewByteArray 创建byte[]数据"></a>频繁NewByteArray 创建byte[]数据</h3><p>JNI 层频繁<code>env-&gt;NewByteArray</code>数据回调到Java层时，因为频繁创建会导致GC频繁回收内存。提升CPU的占用。<br>解决：可以复用缓存，每次使用相同对象回调到Java层，然后Java层使用循环Buffer等进行管理。<br><a id="more"></a></p><h3 id="绑定Java线程-AttachCurrentThread"><a href="#绑定Java线程-AttachCurrentThread" class="headerlink" title="绑定Java线程 AttachCurrentThread"></a>绑定Java线程 AttachCurrentThread</h3><p>当有JNI线程，需要不断异步回调到Java层时，每次都需要将C++线程绑定到JNI线程以进行回调。如果太频繁会占用一定CPU资源。<br>解决：这里推荐使用全局的JavaVM对象和全局的JNIEnv来绑定线程</p><h3 id="JNI异常找不到"><a href="#JNI异常找不到" class="headerlink" title="JNI异常找不到"></a>JNI异常找不到</h3><p>调试时，有时LOG中会显示runtime的异常栈，但是并没有发现JNI层C++代码有啥问题。<br>解决：有可能是Java层异常引起的，JNI层方法的错误。</p><h3 id="使用-addr2line-工具找不到对应行号"><a href="#使用-addr2line-工具找不到对应行号" class="headerlink" title="使用 addr2line 工具找不到对应行号"></a>使用 addr2line 工具找不到对应行号</h3><p>在使用arm-linux-androideabi-addr2line抽取错误栈时，发现错误的行号居然在”}”括号的地方。<br>解决：检查一下so是否是用DEBUG版本但是实际运行是使用RELEASE版本。</p><h3 id="TDOO"><a href="#TDOO" class="headerlink" title="TDOO"></a>TDOO</h3>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AMD平台使用Android官方模拟器</title>
      <link href="/2018/10/02/A013/"/>
      <url>/2018/10/02/A013/</url>
      <content type="html"><![CDATA[<h2 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h2><p>新换了台3A平台电脑，安装AS后，发现没办法使用自带的模拟器。下面记录一下使能的过程。<br><a id="more"></a></p><h2 id="系统平台"><a href="#系统平台" class="headerlink" title="系统平台"></a>系统平台</h2><p>下面是硬件平台参数</p><ul><li>CPU: AMD R5 3600</li><li>主板：微星B450迫击炮</li><li>内存:16GB</li><li>系统:Windows 10专业版 版本号 1903</li></ul><h2 id="使能过程"><a href="#使能过程" class="headerlink" title="使能过程"></a>使能过程</h2><h3 id="开启CPU支持虚拟化"><a href="#开启CPU支持虚拟化" class="headerlink" title="开启CPU支持虚拟化"></a>开启CPU支持虚拟化</h3><p>点击AS中创建虚拟机的方法，提示VT-X、SVM等，稍微搜索了一下发现需要开启主板的虚拟化配置，以提供更好的性能。</p><p>开启的方式很简单，进入BIOS将对应配置打开。微星的主板在CPU特征里面，可能我bios比较新，找了半天。</p><p>开启虚拟化之后，可以在任务管理器的”性能”一栏中，看到CPU虚拟化已启动的标识。</p><h3 id="安装-“Android-Emulator-Hepervisor-Driver-for-AMD-Processors”"><a href="#安装-“Android-Emulator-Hepervisor-Driver-for-AMD-Processors”" class="headerlink" title="安装 “Android Emulator Hepervisor Driver for AMD Processors”"></a>安装 “Android Emulator Hepervisor Driver for AMD Processors”</h3><p>然而，还是不行。AS还是提示我要打开虚拟化。<br>然后搜索stackoverflow。</p><p>发现。AS高版本已经提供AMDCPU对于模拟器的支持！</p><p>你只需要安装”Android Emulator Hepervisor Driver for AMD Processors”就可以了！</p><p>遂，在SDK管理里面，”SDK Tools”的根目录找到了对应的包。<br>重启！并不行！！！难道只能使用Genymotion了吗？？</p><h3 id="开启-Windows-Hypervisor-Platform"><a href="#开启-Windows-Hypervisor-Platform" class="headerlink" title="开启 Windows Hypervisor Platform"></a>开启 Windows Hypervisor Platform</h3><p>于是我又用”AMD”+”模拟器”+<br>“Hyper-V”等关键词搜索，终于找到了下引文2中的参考，需要开启Windwos Hypervisor Platform支持！</p><p>但是咋开启呢！”我的启动或关闭Windows功能”并没有相关内容，只有与Hyper-V开启也没用。</p><p>最后发现仅需要在CMD运行下面神秘的代码即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">::%cd%代表的是执行文件的当前目录，强调bat是在哪里启动的     -&gt;盘符展开后是可改变的</span><br><span class="line">::%~dp0代表的是bat文件所在的文件目录，强调bat的文件位置     -&gt;盘符展开后是不可改变的</span><br><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">::通过通配符获取文件名到hypervisorplatform.txt</span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*HypervisorPlatform*.mum &gt;hypervisorplatform.txt</span><br><span class="line">::循环+拼接安装命令</span><br><span class="line">::/quiet表示静默安装，/norestart表示无需重启（这些参数可酌情使用）</span><br><span class="line">for /f %%i in (&apos;findstr /i . hypervisorplatform.txt 2^&gt;nul&apos;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line">::删除txt</span><br><span class="line">del hypervisorplatform.txt</span><br><span class="line">::启用</span><br><span class="line">Dism /online /enable-feature /featurename:HypervisorPlatform /LimitAccess /ALL</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>注意!<br>上面代码需要复制到文本中，将后缀修改为.cmd,然后用管理员权限启动！重启之后就可以啦！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>x64也是叫AMD64，Android Studio不可能不支持模拟器的！</li><li>Google和百度混合搜索 问题命中率更高。</li></ol><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><ol><li><p><a href="https://blog.csdn.net/L_xiaole/article/details/78202943" target="_blank" rel="noopener">android studio在ADMcpu的电脑上无法开启虚拟机的问题</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2018-07/153114.htm" target="_blank" rel="noopener">Android模拟器Windows版现在支持AMD硬件加速和Hyper-V了</a></p></li><li><p><a href="https://blog.csdn.net/oldfish__/article/details/88641864" target="_blank" rel="noopener">怎么开启windows hypervisor platform,解决hypervisor platform消失无法安装的问题</a></p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android模拟器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RecycleQueue</title>
      <link href="/2018/09/02/A012/"/>
      <url>/2018/09/02/A012/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>在处理较大的byte[]数据时，比如ProtoBuf解析、图像处理、视频编码的场景时，因为生产者和消费者之间的速度不匹配，经常会出现读写导致的数据异常问题，也会因为频繁创建新的对象导致频繁GC。本文介绍了一种可回收的队列、缓存队列来面对这种场景。</p><a id="more"></a><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>首先展示 核心源码细节如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package net.rabbitknight.testapp;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 可回收缓存</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; 泛型 服用的对象</span><br><span class="line"> */</span><br><span class="line">public abstract class RecyclerCache&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存队列</span><br><span class="line">     */</span><br><span class="line">    private final Queue&lt;T&gt; cache = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从缓存中取走一个元素</span><br><span class="line">     *</span><br><span class="line">     * @return T 元素</span><br><span class="line">     */</span><br><span class="line">    public T take() &#123;</span><br><span class="line">        T poll = null;</span><br><span class="line">        // 1. 从缓存中尝试取一个元素</span><br><span class="line">        synchronized (cache) &#123;</span><br><span class="line">            poll = cache.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 若取不到 则用创建方法 创建一个</span><br><span class="line">        if (null == poll) &#123;</span><br><span class="line">            poll = create();</span><br><span class="line">        &#125;</span><br><span class="line">        return poll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将用完的元素回收</span><br><span class="line">     *</span><br><span class="line">     * @param element 不再使用的元素</span><br><span class="line">     * @return 是否回收成功</span><br><span class="line">     */</span><br><span class="line">    public boolean recycle(T element) &#123;</span><br><span class="line">        if (null == element)</span><br><span class="line">            return false;</span><br><span class="line">        return cache.offer(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清理释放所有元素占用</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        synchronized (cache) &#123;</span><br><span class="line">            cache.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 抽象构造方法</span><br><span class="line">     *</span><br><span class="line">     * @return 默认元素</span><br><span class="line">     */</span><br><span class="line">    public abstract T create();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到，该对象为一个抽象类，create()需要实现用以创建新的元素。对象本身包含三个方法take、recycle、clear。take用来获取一个元素，recycle用来将使用过的元素回收以重复使用，clear方法用以完成对对象的清理。</p><p>下面是使用的示例，首先是对象的实例化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class RecycleByte extends RecyclerCache&lt;byte[]&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 抽象构造方法</span><br><span class="line">     *</span><br><span class="line">     * @return 默认元素</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] create() &#123;</span><br><span class="line">        return new byte[1280 * 720];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在代码中重写create方法用来创建新的元素，每次创建一个位1280*720大小的byte[]对象。</p><p>下面是生产者消费者使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 回收缓存</span><br><span class="line"> */</span><br><span class="line">private RecycleByte mRecycleCache = new RecycleByte();</span><br><span class="line">/**</span><br><span class="line"> * 阻塞队里</span><br><span class="line"> */</span><br><span class="line">private BlockingQueue&lt;byte[]&gt; mBlockingQueue = new ArrayBlockingQueue&lt;&gt;(10);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 生产者线程</span><br><span class="line">     */</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 1. 获取一个缓存队列</span><br><span class="line">                byte[] data = mRecycleCache.take();</span><br><span class="line">                // 2. 对数据进行填充,这里只做简单演示</span><br><span class="line">                for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">                    data[i] = 127;</span><br><span class="line">                &#125;</span><br><span class="line">                // 3. 丢到阻塞队列</span><br><span class="line">                boolean rst = mBlockingQueue.offer(data);</span><br><span class="line"></span><br><span class="line">                // 4. 如果阻塞队列没有接收，将数据直接回收</span><br><span class="line">                if (!rst) &#123;</span><br><span class="line">                    mRecycleCache.recycle(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费者线程</span><br><span class="line">     */</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 1. 从阻塞队列拉取元素</span><br><span class="line">                byte[] data = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data = mBlockingQueue.poll(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2. 处理数据: 这里只是打印</span><br><span class="line">                System.out.println(Arrays.toString(data));</span><br><span class="line"></span><br><span class="line">                // 3. 缓存回收</span><br><span class="line">                boolean rst = mRecycleCache.recycle(data);</span><br><span class="line">                if (!rst) &#123;</span><br><span class="line">                    System.out.println(&quot;recycle [&quot; + data + &quot;], fail!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中 生产者线程不断从队列中获取元素加入到缓存队列中，消费者线程，不断从阻塞队列中获取元素做异步处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的代码只是简单的展示一下如何做到缓存复用以优化大对象频繁创建的场景。<br>在实际使用中，配合阻塞队列做冗余，以应对生产者消费者之间的速度不匹配问题。</p><p>— end —</p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JAVA </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深拷贝VS浅拷贝</title>
      <link href="/2018/07/02/A011/"/>
      <url>/2018/07/02/A011/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>[水]<br>简单来说就一句话：非基本类型是否使用 引用赋值。<br>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">额，举毛线。</span><br></pre></td></tr></table></figure><p>— end —</p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JAVA </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>沉浸式状态栏之fitsystemWindows</title>
      <link href="/2018/06/26/A010/"/>
      <url>/2018/06/26/A010/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 沉浸式状态栏中经常会看到使用<code>fitsystemwindow = true;</code> 让布局延伸到状态栏以下。但是经常会出现Toolbar也会进入到状态栏下面，或者状态栏直接变成白色的情况。<br>那出现这种情况的原因到底是什么呢？<br><a id="more"></a></p><h3 id="什么是fitsystemwindow"><a href="#什么是fitsystemwindow" class="headerlink" title="什么是fitsystemwindow"></a><center>什么是fitsystemwindow</center></h3><p>其实只想说一句话。。</p><blockquote></blockquote><p><strong><font color="red">fitsystemwindow相当于给布局设置了一个padding属性。</font></strong></p><p>emmm，就这样。。。至于是paddingTop还是paddingBottom得看布局所在的位置。</p><h3 id="WHAT’S-MORE-？"><a href="#WHAT’S-MORE-？" class="headerlink" title="WHAT’S MORE ？"></a><center>WHAT’S MORE ？</center></h3><p>给篇分析很透彻的文章。</p><p><a href="https://www.jianshu.com/p/28f1954812b3" target="_blank" rel="noopener">全屏、沉浸式、fitSystemWindow使用及原理分析：全方位控制“沉浸式”的实现 - 简书</a></p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>持久化方案断电测试对比</title>
      <link href="/2018/02/26/A009/"/>
      <url>/2018/02/26/A009/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>问题描述：<br>当Android 机器突然断电时，如果此时正在进行文件的读写操作，文件会处于不安全状态，可能<br>会导致文件的丢失。<br>原因：<br>Linux/Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘。<br>正常的文件写入流程为：<br>用户程序-&gt;用户缓冲-&gt;内核缓冲-&gt;物理介质<br>因此当FileOutputStream 处于write并没有进行flush操作，文件仅处于于缓存中，没有写入磁盘介质，此时突然断电，用户程序丢失文件缓存，文件就丢失了。<br>因此，设计到文件的程序都可能引起文件丢失问题。<br><a id="more"></a></p><h3 id="持久化方案选择"><a href="#持久化方案选择" class="headerlink" title="持久化方案选择"></a>持久化方案选择</h3><h4 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h5><p>SharedPreference字面上意思为共享的偏好。用以存储用户的一些简单的配置信息，例如夜间模式、用户登录信息等。存放目录为/data/data/appname/shared_prefs/xxx.xml文件中。并以键值对的形式存储数据。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;</span><br><span class="line">&lt;string name=&quot;4957&quot;&gt;4957&lt;/string&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p>SharePreferences是线程安全的，但是并不是进程安全。</p><h5 id="断电测试"><a href="#断电测试" class="headerlink" title="断电测试"></a>断电测试</h5><p>下面使用Runnable进行1w条数据的循环写入测试。</p><ol><li>进行插入操作。</li><li>系统在apply2404条数据后，手动断电。</li><li>恢复电源。进入<code>/data/data/appname/shared_prefs</code>目录下，发现 test.xml文件仍在。</li><li>重新运行测试app，进行读取操作，发现 仅能读取295条数据。</li><li>在shell命令中，将test.xml手动删除。在未重启测试程序的情况下重新读取，发现仍能读取出295条数据。</li><li>故得出推论：使用SharePreferences，在频繁大量写入时，如果突然断电，部分的数据因为暂时存储在缓存中没有调用<code>Editor.commit()</code> 导致事务没来得及保存，但文件并不会丢失。</li></ol><p><strong>!!!上述问题 实际在存储到2404条内容超过3gb引起OOM异常了。。</strong>上述结论均不成立!。</p><ol><li>真正结论是SharePreferences在读写的过程中会把整个xml文件拿出来，导致占用过多的运行空间， SharePreferences推荐用于轻量级别的数量存储！</li><li>同时！当oom异常后会有test.xml.bak的备份文件出现。当重新运行后，调用<code>Activity.getSharedPreferences</code>方法时被恢复。但是数据仅有295条数据</li><li>重新测试，插入2000条数据，ok并没有出现问题。</li><li>现在，在插入每一条数据后，线程sleep+1s。拔掉电源，查看状态。插入69条数据时，断电。恢复电源重新运行设备。进行读取，发现可以成功读取69条数据。<br>推论：SharePreferences低频存储时，当突然断电，数据存在消失风险，但是SharePreferences有备份机制，存储的数据完整性较好。但是存储读取效率不高，内存出现抖动。</li></ol><blockquote><p>参考</p><ol><li><a href="https://juejin.im/entry/597446ed6fb9a06bac5bc630" target="_blank" rel="noopener">彻底搞懂 SharedPreferences - Android - 掘金</a><br>2.<a href="http://extremej.itscoder.com/shared_preferences_source" target="_blank" rel="noopener">对 SharedPreferences 再多一点了解 | Joe is a thin man</a></li></ol></blockquote><h4 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h4><h5 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h5><p>sqlite是Android上使用的轻量级别的数据库。</p><h5 id="断电测试-1"><a href="#断电测试-1" class="headerlink" title="断电测试"></a>断电测试</h5><p>测试使用了GreenDao作为数据库orm库。GreenDao使用插件编译成sql语言，解析速度最快。</p><ol><li>首先断电。插入循环1w条数据，在系统关闭之前 1w条数据已经插入完成。</li><li>恢复电力，进入databases查看。，发现test.db仍存在。</li><li>运行测试程序进行读取。发现取出的数据数为1w。数据并未丢失。</li><li>现在在插入每一条数据后线程sleep 1s；在插入69条数据时，系统关闭。</li><li>重启机器，进行查询操作，发现能够查到73条数据。。</li><li>推测 logcat还没成功打印出来插入操作已经结束。</li></ol><p>因此，使用SQLite能够较为快速的存储数据，同时能够较好的保持数据的完整性。</p><h6 id="ORM选择"><a href="#ORM选择" class="headerlink" title="ORM选择"></a>ORM选择</h6><p>ORM即 Object Relational Mapping 对象关系映射。Android/Java开发者更应该聚焦的是对于对象的处理。虽然Android有SQLiteOpenHelper帮助我们处理数据库，但是需要编写SQL语句，而且SQL语句的规范不能良好的检测。同时一些事务处理机制例如多线程等需要自己来实现，很麻烦。<br>现在网上有不少开源库，例如GreenDao，realm，LitePal等。LitePal为较新框架作者是郭霖，目前有4.5k star。GreenDao在github上有9.8k的star。Realm有9.2k。</p><ul><li><p>LitePal的bean对象需要继承DataSupport，同时需要编写asset文件。</p></li><li><p>Realm需要继承RealmObject，虽然跨平台，但是有一定的限制。</p></li><li>GreenDao实际使用构建工具将sql语句生成出来，同时生成Dao类用于完成各种数据库操作，也保持原pojo类的独立性。因为GreenDao实际的底层使用sql语句，故效率上很高。网上也有较多文档供参考。 同时开源库小于100KB</li></ul><p>ORM第三方库选择参考：</p><ol><li><a href="https://juejin.im/post/5958fe70f265da6c49777c94" target="_blank" rel="noopener">Android目前流行三方数据库ORM分析及对比 - 掘金</a></li><li><a href="https://juejin.im/post/5959b5bcf265da6c4d1bb245" target="_blank" rel="noopener">Android ORM 框架：GreenDao 使用详解（基础篇） - 掘金</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1203/3743.html" target="_blank" rel="noopener">为什么我不再使用Realm - 泡在网上的日子</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anroid </tag>
            
            <tag> 持久化 </tag>
            
            <tag> SQLite </tag>
            
            <tag> SharedPreferences </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写了一个Gank客户端</title>
      <link href="/2018/01/25/A008/"/>
      <url>/2018/01/25/A008/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>摸鱼用<a href="http://gank.io/api" target="_blank" rel="noopener">gank.io</a>公开API写了个练手项目。主要是在实际的项目中使用一些主流的技术，诸如MVP，RxJava，Dagger等。<br><strong>项目地址：</strong><a href="https://github.com/rabbitknight/GankU" target="_blank" rel="noopener">GankU:https://github.com/rabbitknight/GankU</a><br><a id="more"></a></p><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a><center>TL;DR</center></h3><table><thead><tr><th>技术</th><th>概要</th></tr></thead><tbody><tr><td>RxJava2+Retrofit</td><td>RxJava仅配合Retrofit，作为网络请求资源的处理使用。</td></tr><tr><td>MVP</td><td>使用mvp架构思想，M层未做较优处理。V、P层隔离、仅接口访问。Activity与Fragment既是V层，又是P与V结合的地方。</td></tr><tr><td>Dagger2</td><td>强化Dagger的使用，P层、控件、网络请求均使用Dagger注入到Act\Frag。</td></tr><tr><td>M D</td><td>使用ToolBar、NavView、SRL、CoordinatorLayout等。</td></tr><tr><td>Animator</td><td>部分使用了属性动画、包含animated-vector向量动画的使用。</td></tr><tr><td>Custom View</td><td>为ImageView添加包装类实现手势操作，一个使用了贝塞尔曲线的indicator，自定义的ItemDecoration等。</td></tr><tr><td>Web</td><td>使用腾讯X5内核作为WebView，待添加CustomTabs获取更优秀的效果。</td></tr><tr><td>…</td><td>…</td></tr><tr><td>—</td><td>—</td></tr></tbody></table><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><center>项目结构</center></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">└─ganku</span><br><span class="line">    ├─common+ common包，静态变量等</span><br><span class="line">    ├─di+ dagger依赖注入包</span><br><span class="line">    │  ├─component- 注射器 </span><br><span class="line">    │  ├─module- 模块</span><br><span class="line">    │  └─scope- 作用域</span><br><span class="line">    ├─mvp+ mvp包，项目为mvp架构</span><br><span class="line">    │  ├─model+ 数据层，有缺陷</span><br><span class="line">    │  │  └─remote- bean类等</span><br><span class="line">    │  ├─presenter+ 表现层，专注业务逻辑处理</span><br><span class="line">    │  │  ├─base- 最基本接口</span><br><span class="line">    │  │  ├─impl- 接口实现</span><br><span class="line">    │  │  └─interfaces- 集成接口</span><br><span class="line">    │  └─view+ 显示层，专注View的显示</span><br><span class="line">    │      ├─base- 最基本的接口</span><br><span class="line">    │      ├─interfaces- 集成接口</span><br><span class="line">    │      └─ui+ ui显示包，接口实现</span><br><span class="line">    │          ├─activity- Activity</span><br><span class="line">    │          ├─adapter- 适配器</span><br><span class="line">    │          ├─fragment- 碎片，用于显示</span><br><span class="line">    │          ├─listener- 监听器</span><br><span class="line">    │          └─widget- 自定义组件</span><br><span class="line">    ├─net+ 网络访问包，注：已被废弃</span><br><span class="line">    │  └─api- Retorfit的接口</span><br><span class="line">    └─utils+ utils辅助类，String处理等</span><br></pre></td></tr></table></figure><h3 id="运行Demo"><a href="#运行Demo" class="headerlink" title="运行Demo"></a><center>运行Demo</center></h3><table><thead><tr><th>desc</th><th>img</th></tr></thead><tbody><tr><td>launcher</td><td><img src="https://github.com/rabbitknight/GankU/blob/master/gifs/gif_launcher2.gif?raw=true" alt="launcher"></td></tr><tr><td>main</td><td><img src="https://github.com/rabbitknight/GankU/blob/master/gifs/gif_main1.gif?raw=true" alt="main1"></td></tr><tr><td>main2</td><td><img src="https://github.com/rabbitknight/GankU/blob/master/gifs/gif_main2.gif?raw=true" alt="main2"></td></tr><tr><td>Web</td><td><img src="https://github.com/rabbitknight/GankU/blob/master/gifs/gif_web.gif?raw=true" alt="web"></td></tr><tr><td>—</td><td>—</td></tr></tbody></table><h3 id="使用技术："><a href="#使用技术：" class="headerlink" title="使用技术："></a><center>使用技术：</center></h3><p>参考build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">compile &apos;com.android.support:support-v4:26.1.0&apos;</span><br><span class="line">compile &apos;com.android.support:design:26.1.0&apos;</span><br><span class="line">compile &apos;com.android.support:recyclerview-v7:26.1.0&apos;</span><br><span class="line">compile &apos;com.android.support:cardview-v7:26.1.0&apos;</span><br><span class="line">compile &apos;com.android.support:customtabs:26.1.0&apos;</span><br><span class="line">testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">compile &apos;com.google.dagger:dagger:2.13&apos;</span><br><span class="line">annotationProcessor &apos;com.google.dagger:dagger-compiler:2.13&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxjava:2.1.6&apos;</span><br><span class="line">compile &apos;com.github.bumptech.glide:glide:4.3.1&apos;</span><br><span class="line">annotationProcessor &apos;com.github.bumptech.glide:compiler:4.3.1&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.3.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;</span><br><span class="line">compile &apos;com.squareup.okhttp3:okhttp:3.9.0&apos;</span><br><span class="line">compile &apos;com.jakewharton:butterknife:8.4.0&apos;</span><br><span class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</span><br></pre></td></tr></table></figure></p><h3 id="一点点总结"><a href="#一点点总结" class="headerlink" title="一点点总结"></a><center>一点点总结<center></center></center></h3><ol><li>关于Dagger2的依赖注入，看到一些github上的同级别项目，并没有将Dagger这一流痞的库很好的使用他们在Activity中仍然很多<code>new Clazz();</code>。为此，我强化了Dagger的使用，致使项目中MVP中的P层使用依赖注入到Activity\Fragment，同时很多的View要么使用ButterKnife，要么使用Dagger注入到相应位置，使得在项目中基本看不到<code>new Clazz();</code> 这种方法。</li><li>关于MVP项目，借助于Dagger2的使用，使得MVP三层分离的比较彻底。三层各司其职，仅通过接口访问，OOP。<ul><li>View层专注于界面的显示，其向外暴露的接口仅用于控制界面的显示效果。</li><li>Presenter层专注于事务，它通过View层接口传递的信息，进行逻辑处理，并调用V层暴露的接口控制View层界面做出改变。</li><li>Model层专注于数据，道理上说，V层的事件交于P层处理，P层可能会调用M层的接口获取一些数据。然而因为强化Dagger的使用，我将RRO的网络访问框架直接注入到了P层–，那么M层就一下子消失了–，所以实际上框架可能实际只是MV<strike>p</strike>，<strong>还不是MVP。但是使用思想并不意味着要完全实现。</strong></li><li>Activity\Fragment既是View又是P层与V层结合的地方。Act与Frag对于Android来说既是一个View显示的地方又是一个做逻辑处理。</li><li>在MVC思想中，V实际代表的是XML布局，那么C在Android中就是Activity等，对应的很好。但是对于MVP，我们将P层抽离，但是P层又仅能在Activity中被调用，依赖Act存在。而Act又是某种意义上的View，这时的Activity的地位就稍微有点尴尬了。因此实际上，私以为Android中的MVP思想实际是一种<strong>代理模式</strong>。<del>这种说法对于大部分和用户交互的App应该是没问题的。</del></li></ul></li><li>Rx系函数式编程。函数式编程、响应式编程我了解比较浅，对于这种编程思想来说，一个函数的输出作为另一种函数的输入。函数相互调用形成一种链状的<strong>“流”</strong>。这与观察者模式不谋而合，通过对这种思想的使用，使得整个工程结构更加清晰，我们只需关注每个函数流的流向即每个函数的功能，将每个逻辑单独抽离，而不关注具体的实现，这使得项目更加清晰，也符合OOP的原则、高内聚低耦合。</li><li>关于自定义View，至今，据我了解，Android从业者呈现一种金字塔形势分布，较为低级的人员充斥在这个市场当中，但越往上的能力者越少。我也在想从13年移动行业的井喷式增长开始，到18年我该毕业的今天，拥有5年左右的开发者，他们在整个行业中处于什么样的地位，他们拥有怎样的技能树。我遇到的人，还是较少，暂不能得到答案。但以不变应万变，基础的东西的变化仍然是较低的，对于自定义View的掌握肯定是必要的。如今开发，想要获得一个效果，搜一下第三方库就很多。虽不要重复早轮子，但是前提是会造轮子。不需要知道细枝末节，但是对于脉络原理还是要知道的。为此学习一些自定义View是很必要的。我在这个项目中实现了一个贝塞尔拟合圆的ViewPager指示器，实际挺简单，300行左右的代码但是对于自定义View的收获还是挺多的。</li><li>MD，Material Design是一种设计风格，与IOS的扁平化相对应。目前大部分的App，还是喜欢和IOS对齐，这也没错。我所了解的App中Android端的BiliBili、网易云等对于MD的应用最为出色。可能我们不是写UI的不需要设计的很好看，但是去发现美（无论是何种美）确实应该去做的。</li><li>。。。</li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><center>TODO<center></center></center></h3><ul><li>IMG<ul><li>ImageViewWrap，手势包装类的优化</li><li>妹子图的下载收藏等</li></ul></li><li>Web<ul><li>CustomTab的集成，获取更好体验</li><li>右上角分享、复制URL等功能</li></ul></li><li>主页<ul><li>主题切换</li><li>部分细节优化</li></ul></li><li>…<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a><center>Thanks</center></h3></li></ul><ol><li>首先感谢<a href="http://gank.io/api" target="_blank" rel="noopener">gank.io</a> 家的API。</li><li>然后某些界面的设计理念参考<del>（读书人的事情不能用抄）</del>了一些例子。</li></ol><ul><li><a href="https://github.com/qdxxxx/BezierViewPager" target="_blank" rel="noopener">BezierViewPager</a></li><li><a href="https://github.com/Wensibob/GankClient" target="_blank" rel="noopener">GankClient</a></li><li><a href="https://github.com/Bakumon/UGank" target="_blank" rel="noopener">UGank</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> MVP </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Retrofit2 </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Custom View </tag>
            
            <tag> Material Design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android OpenGL简单总结</title>
      <link href="/2018/01/08/A007/"/>
      <url>/2018/01/08/A007/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>学习了一点OpenGL相关的知识。做个总结以防遗忘。</p><h3 id="OpenGL简介"><a href="#OpenGL简介" class="headerlink" title="OpenGL简介"></a>OpenGL简介</h3><p>OpenGL即Open Graphics Library，开放图形库，是一个跨平台的，专业的图形程序接口，用于绘制渲染2D、3D适量图片。OpenGL有自己的着色器语言，Graphics Library Shader Language，GLSL。<br>在android中，涉及到一些图形、视频的绘制，会用到这个，因为它很快。。Android对于openGL的支持如下所示<br><a id="more"></a></p><blockquote><p>OpenGL ES 1.0 and 1.1 - This API specification is supported by Android<br>1.0 and higher. OpenGL ES 2.0 - This API specification is supported by Android 2.2 (API level 8) and higher. OpenGL ES 3.0 - This API<br>specification is supported by Android 4.3 (API level 18) and higher.<br>OpenGL ES 3.1 - This API specification is supported by Android 5.0<br>(API level 21) and higher.</p></blockquote><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a><center>重要概念</center></h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>在OpenGL的世界中，有三个要素组成，点、线、三角形。所有的2D/3D图形都是由这这几个构成的，通过一个个的三角形拼成模型，然后为每一个三角形绘制纹理等来构成这个2D/3D的图片。（我的理解可能比较浅）</p><h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4><ol><li>在Android中，我们默认的坐标系为以屏幕左上角为坐标原点，以水平向左为X轴，以水平向下为Y轴，构成X0Y坐标系。</li><li>OpenGL的世界坐标系，首先它假定屏幕为正方形，以屏幕中心为坐标原点，以水平向右为X轴，以水平向上为Y轴，以垂直屏幕向上为Z轴，同时视原点到屏幕边缘为单位1。OpenGL中使用SWT坐标系。</li><li>建模坐标系，绘制图形的坐标系，初始与世界坐标系重合。伸缩变换后进行改变。</li></ol><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>着色器，Shader是GPU上运行的程序。</p><ol><li>顶点着色器，GPU通过顶点着色器处理顶点信息，将虚拟的三维坐标处理为屏幕上显示的二维坐标。顶点着色器可以进行位置、颜色、纹理坐标操作。<br>它将会输出Varying、gl_Position、gl_FrontFacing、gl_PointSize等。</li><li>片元着色器，用于计算每个像素的颜色和其他属性来进行输出。<br>它将会输出gl_FragColor等。</li></ol><h4 id="绘制过程和理解"><a href="#绘制过程和理解" class="headerlink" title="绘制过程和理解"></a>绘制过程和理解</h4><ul><li>过程：读取顶点-&gt;执行顶点着色器-&gt;组装图元-&gt;光栅化图元-&gt;执行片元着色器-&gt;写入帧缓冲区-&gt;显示到屏幕上。</li><li>OpenGL直接与GPU打交道,因此数据要由JAVA层转到OpenGL层。顶点着色器对每个顶点执行、片元着色器对每个片元执行。</li><li>OpenGL程序将着色器进行编译将顶点着色器和片元着色器链接到OpenGL程序中。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><center>实例</center></h3><p>本例将从一帧RGB数据显示到屏幕上为例。看一下实现的过程。</p><ul><li>着色器的定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//vertexShader.glsl</span><br><span class="line">attribute vec4 aPosition;// 顶点坐标</span><br><span class="line">attribute vec2 aTextureCoord;// 纹理坐标</span><br><span class="line">varying vec2 vTextureCoord;// 传递的文理坐标系</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">gl_Position = aPosition;// gl_Position为内部的顶点坐标，这里将顶点坐标传递过去</span><br><span class="line">vTextureCoord = aTextureCoord;//将纹理坐标传递给用于传递的坐标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//fragmentShader.glsl</span><br><span class="line">varying lowp vec2 vTextureCoord;// 这里为接收传递值的的纹理坐标</span><br><span class="line">uniform sampler2D samplerRGB;// 声明一个纹理采样器，把纹理添加到着色器中</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;//gl_FragColor为当前片元的颜色</span><br><span class="line">//texture2D为纹理采样函数，俩参数分别是纹理采样器、纹理坐标。</span><br><span class="line">//这里将纹理坐标顶点的坐标传递过来，进行纹理采样，返回片元的颜色。</span><br><span class="line">    gl_FragColor = texture2D(samplerRGB,vTextureCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>坐标定义</li></ul><p>对于OpenGL的绘制，这里单独开了一个线程结合TextureSurface进行绘制。Java层对于OpenGL的操作使用了OpenGL ES。<br>因为OpenGL的图形都是使用三角形进行拼接，待绘制的区域（整块屏幕），可以看成是俩三角拼接而成的，因此绘制区域对应的顶点坐标为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//java OpenGL接收的只能是java.nio类型的，所以最后都要转成FloatBuffer</span><br><span class="line">private FloatBuffer mSquareVerticesBuffer;</span><br><span class="line">// 屏幕对应的顶点坐标</span><br><span class="line">private static float squareVertices[] = &#123;</span><br><span class="line">        -1.0f, 1.0f, 0.0f,    // 左上角</span><br><span class="line">        -1.0f, -1.0f, 0.0f,   // 左下角</span><br><span class="line">        1.0f, -1.0f, 0.0f,    // 右下角</span><br><span class="line">        1.0f, 1.0f, 0.0f      // 右上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对于接收到的RGB字节流，要进行纹理采样，这里也需要标定坐标。下面是坐标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 纹理对应顶点，同理</span><br><span class="line">private FloatBuffer mTextureVerticesBuffer;</span><br><span class="line">//纹理对应的顶点坐标</span><br><span class="line">private static float textureVertices[] = &#123;</span><br><span class="line">        0.0f, 0.0f,    // 左上角</span><br><span class="line">        0.0f, 1.0f,    // 左下角</span><br><span class="line">        1.0f, 1.0f,    // 右下角</span><br><span class="line">        1.0f, 0.0f     // 右上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里可以看到，android坐标与OpenGL坐标的不同；<br>然后初始化 屏幕顶点坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void initVertex() &#123;</span><br><span class="line">    //将顶点坐标由数组放到ByteBuffer,order是指大顶端小顶端设置为与native同步，作为浮点存储</span><br><span class="line">    mSquareVerticesBuffer = ByteBuffer.allocateDirect(FLOAT_SIZE_BYTES * squareVertices.length).</span><br><span class="line">            order(ByteOrder.nativeOrder()).</span><br><span class="line">            asFloatBuffer();</span><br><span class="line">    mSquareVerticesBuffer.put(squareVertices);</span><br><span class="line">    mSquareVerticesBuffer.position(0);</span><br><span class="line">    mTextureVerticesBuffer = ByteBuffer.allocateDirect(FLOAT_SIZE_BYTES * textureVertices.length).</span><br><span class="line">            order(ByteOrder.nativeOrder()).</span><br><span class="line">            asFloatBuffer();</span><br><span class="line">    mTextureVerticesBuffer.put(textureVertices);</span><br><span class="line">    mTextureVerticesBuffer.position(0);</span><br><span class="line">    mDrawIndicesBuffer = ByteBuffer.allocateDirect(SHORT_SIZE_BYTES * drawIndices.length).</span><br><span class="line">            order(ByteOrder.nativeOrder()).</span><br><span class="line">            asShortBuffer();</span><br><span class="line">    mDrawIndicesBuffer.put(drawIndices);</span><br><span class="line">    mDrawIndicesBuffer.position(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>纹理</li></ul><p>通过下面的代码来初始化纹理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void initTexture() &#123;</span><br><span class="line">//开启2D纹理开关</span><br><span class="line">    GLES20.glEnable(GLES20.GL_TEXTURE_2D);</span><br><span class="line">    //激活纹理单元</span><br><span class="line">    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">    //创建RGB纹理</span><br><span class="line">    createTexture(mWidth,mHeight,GLES20.GL_RGB,rgbTexture);</span><br><span class="line">    GLES20.glUseProgram(mProgram);</span><br><span class="line">    //获取纹理坐标点</span><br><span class="line">    sampleRGBLocation = GLES20.glGetUniformLocation(mProgram,&quot;samplerRGB&quot;);</span><br><span class="line">    //通知采样器纹理坐标</span><br><span class="line">    GLES20.glUniform1i(sampleRGBLocation,0);</span><br><span class="line">    //获取顶点坐标</span><br><span class="line">    int aPostionLocation = GLES20.glGetAttribLocation(mProgram, &quot;aPosition&quot;);</span><br><span class="line">    //获取纹理顶点坐标</span><br><span class="line">    int aTextureCoordLocation = GLES20.glGetAttribLocation(mProgram, &quot;aTextureCoord&quot;);</span><br><span class="line">    //传入顶点坐标</span><br><span class="line">    GLES20.glEnableVertexAttribArray(aPostionLocation);</span><br><span class="line">    GLES20.glVertexAttribPointer(aPostionLocation, COORDS_PER_VERTEX,</span><br><span class="line">            GLES20.GL_FLOAT, false,</span><br><span class="line">            COORDS_PER_VERTEX * 4, mSquareVerticesBuffer);</span><br><span class="line">    //传入纹理坐标</span><br><span class="line">    GLES20.glEnableVertexAttribArray(aTextureCoordLocation);</span><br><span class="line">    GLES20.glVertexAttribPointer(aTextureCoordLocation, TEXTURE_COORS_PER_VERTEX,</span><br><span class="line">            GLES20.GL_FLOAT, false,</span><br><span class="line">            TEXTURE_COORS_PER_VERTEX * 4, mTextureVerticesBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在createTexture中，我们创建纹理坐标。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void createTexture(int width, int height, int format, int[] texture) &#123;</span><br><span class="line">    //创建纹理</span><br><span class="line">    GLES20.glGenTextures(1, texture, 0);</span><br><span class="line">    //必须调用glBindTexture将纹理进行绑定</span><br><span class="line">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture[0]);</span><br><span class="line">    //设置纹理的具体细节，S、T、W为坐标系，参考X、Y、Z坐标系</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class="line">    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">    //加载纹理，最后一个参数为纹理的数据，我们此时还没给其设置rgb数据</span><br><span class="line">    //第一个format参数为将纹理存储为的格式，第二个format为图片来源的数据格式</span><br><span class="line">    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, format, width, height, 0, format,  GLES20.GL_UNSIGNED_BYTE,null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>绘制</li></ul><p>在创建完纹理过后，会对纹理进行回执，此时，绘制使用glTexSubImage2D这个函数进行，此函数用于纹理的修改。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void drawFrame() &#123;</span><br><span class="line">    //设置绘制区域</span><br><span class="line">    GLES20.glViewport(0, 0, sw, sh);</span><br><span class="line">    //清屏颜色(RGBA) 取值范围是0～1不是0～255</span><br><span class="line">    GLES20.glClearColor(1.0f, 0.0f, 0.0f, 0.0f);</span><br><span class="line">    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">    GLES20.glUseProgram(mProgram);</span><br><span class="line">    </span><br><span class="line">    //直接绘制rgb数据</span><br><span class="line">    //glTexSubImage2D 用于更改数据</span><br><span class="line">    //syncBuff为一数据同步锁，因为实际会不断获取一帧一帧的数据</span><br><span class="line">    synchronized (syncBuff) &#123;</span><br><span class="line">    //激活纹理</span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">        //绑定纹理</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, rgbTexture[0]);</span><br><span class="line">        //进行绘制</span><br><span class="line">        GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0,</span><br><span class="line">                mWidth,    //绘制的宽度</span><br><span class="line">                mHeight,   //绘制的高度</span><br><span class="line">                GLES20.GL_RGB,    //绘制的格式</span><br><span class="line">                GLES20.GL_UNSIGNED_BYTE,    //数据类型</span><br><span class="line">                rgbBuf);   //数据</span><br><span class="line">    &#125;</span><br><span class="line">    //使用该函数告诉OpenGL如何进行纹理采样，这里使用了采样的顶点，具体暂不表</span><br><span class="line">    GLES20.glDrawElements(GLES20.GL_TRIANGLES, drawIndices.length, GLES20.GL_UNSIGNED_SHORT, mDrawIndicesBuffer);</span><br><span class="line">    //绘制结束</span><br><span class="line">    GLES20.glFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h4><p>上述代码仅仅是大概的绘制过程，并没有下面的相关代码：</p><ul><li>OpenGL的创建以及初始化过程</li><li>OpenGL着色器语言获取以及配置过程</li><li>使用TextureView等android组件进行具体绘制的逻辑</li><li>其他</li></ul><h3 id="参考引文"><a href="#参考引文" class="headerlink" title="参考引文"></a><center>参考引文</center></h3><p>部分（滑稽）内容参考以下博客。</p><ul><li><a href="http://pengzhendong.cn/2016/01/22/OpenGL-Coordinates/" target="_blank" rel="noopener">OpenGL 中的坐标系 | Randy’s Notes</a></li><li><a href="http://blog.csdn.net/junzia/article/details/52793354" target="_blank" rel="noopener">Android OpenGLES2.0（一）——了解OpenGLES2.0 - CSDN博客</a></li><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">纹理 - LearnOpenGL-CN</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android USB相关</title>
      <link href="/2017/12/22/A006/"/>
      <url>/2017/12/22/A006/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>公司最近需要在android 设备中进行usb 摄像头通信。为此学习一些与USB相关的知识。下面是一些总结，推荐一个已经封转好的框架<a href="https://github.com/saki4510t/UVCCamera" target="_blank" rel="noopener">UVCCamera</a>。<br><a id="more"></a></p><h3 id="Android-USB基础"><a href="#Android-USB基础" class="headerlink" title="Android USB基础"></a>Android USB基础</h3><p><a href="https://developer.android.com/guide/topics/connectivity/usb/index.html" target="_blank" rel="noopener">参考官方文档</a>，Android支持USB模式主要通过两种方式：USB accessory 和 USB host，即附件模式和主机模式。<br>Android 两种模式的支持最终取决于设备的硬件。</p><h4 id="USB-Host"><a href="#USB-Host" class="headerlink" title="USB Host"></a>USB Host</h4><p>Android设备充当主设备，并为总线供电。比如 相机、键鼠，USB设备与Android应用进行数据交互。</p><h4 id="USB-Accessory"><a href="#USB-Accessory" class="headerlink" title="USB Accessory"></a>USB Accessory</h4><p>外部硬件充当主设备，为总线供电。比如手机连电脑。</p><h4 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h4><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>UsbManager</td><td>列举USB设备、和USB设备通信</td></tr><tr><td>UsbDevice</td><td>代表连接的USB设备，包含标识、接口、端点的方法。可拥有不止一个接口用来通信</td></tr><tr><td>UsbInterface</td><td>表示UsbDevice的一个接口</td></tr><tr><td>UsbEndpoint</td><td>表示UsbInterface的一个端点，接口通信通道</td></tr><tr><td>UsbDeviceConnection</td><td>表示与设备的连接，收发数据，传输控制信息</td></tr><tr><td>UsbRequest</td><td>通信请求，通过UsbDeviceConnection进行异步请求</td></tr><tr><td>UsbConstants</td><td>USB常量，与Linux /usb/ch9.h中定义相对应</td></tr></tbody></table><h4 id="Android-Manifest要求"><a href="#Android-Manifest要求" class="headerlink" title="Android Manifest要求"></a>Android Manifest要求</h4><ol><li>包含&lt; uses-feature &gt; 来声明应用使用android.hardware.usb.host功能。</li><li>最低API 12</li><li>设备拔插通知，在活动中为android.hardware.usb.action.USB_DEVICE_ATTACHED，指定&lt; intent-filter &gt;和 &lt; meta-data &gt;。后者指向外部XML资源，声明设备信息。</li><li>在XML中，声明&lt; usb-device &gt;元素包含，vendor-id、product-id、class、subclass、protocol等。</li></ol><h3 id="USB-权限获取"><a href="#USB-权限获取" class="headerlink" title="USB 权限获取"></a>USB 权限获取</h3><p>USB权限的获取通过广播的方式进行。</p><h4 id="manifest定义"><a href="#manifest定义" class="headerlink" title="manifest定义"></a>manifest定义</h4><ol><li>首先在manifest的根节点做如下声明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature</span><br><span class="line">    android:name=&quot;android.hardware.usb.host&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol><p>代表机器会使用android usb 的host模式。</p><ol start="2"><li>在使用USB的activity中设置意图过滤intent-filter，如下所示。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.activity.MainActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; /&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.hardware.usb.action.USB_DEVICE_DETACHED&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li></ol><p>我们需要指定action，其中USB_DEVICE_ATTACHED和USB_DEVICE_DETACHED是USB插拔的过滤，通过以上声明，我们的Activity就可只接收到USB设备的拔插监听。</p><ol start="3"><li>因为并不是所有设备的拔插我们都是需要的，为此要加入设备的过滤。<br>新建xml Resources文件夹，如下添加我们的设备。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;usb-device vendor-id=&quot;1423&quot; product-id=&quot;866&quot;/&gt;</span><br><span class="line">    &lt;usb-device vendor-id=&quot;1133&quot; product-id=&quot;1002&quot;/&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li></ol><p>其中vendor-id和product-id分别是厂商的id和产品的id，一般usb硬件都有这俩个。你也可以指定别的xxx-id。<br>然后在manifest中，在2.的后面添加&lt; meta-data&gt;如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;meta-data android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot;</span><br><span class="line">    android:resource=&quot;@xml/device_filter&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>如上就设置好manifest了。</p><h4 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h4><p>权限申请需要使用UsbManager.requestPermission(UsbDevice,PendingIntent)这个函数，UsbDevice即为待申请权限的USB设备。PendingIntent为待处理意图，可以理解为未处理的Intent。UsbDevice为获取到的，Pending为定义的，方式如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final String ACTION_USB_PERMISSION =</span><br><span class="line">            &quot;cc.hobot.USB_PERMISSION.UVC_CAMERA&quot;;       //权限Action</span><br><span class="line">private PendingIntent mPermissionIntent;</span><br><span class="line">...</span><br><span class="line">mPermissionIntent = PendingIntent.getBroadcast(context,0,new Intent(ACTION_USB_PERMISSION),0);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>ACTION_USB_PERMISSION为自定义的Action的name。在创建PendingIntent时，交给PendingItent。<br>申请权限仅需要调用UsbManager.requestPermission(UsbDevice,PendingIntent)就可以了。当然，此时仅是申请，此时屏幕上就会出现提示你确定usb的权限。那此时，根据在屏幕上的点击，进行下一步操作，下一步的操作，会在广播的Reciver中进行。</p><h4 id="广播定义"><a href="#广播定义" class="headerlink" title="广播定义"></a>广播定义</h4><p>这里的广播用来接收诸如USB设备的拔插，以及权限申请的广播信息。我们需要创建一个UsbReciver继承BroadcastReciver。代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * usb事件广播接收</span><br><span class="line"> */</span><br><span class="line">private BroadcastReceiver mUsbReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        final String action = intent.getAction();   //根据Action判断行为 </span><br><span class="line">        if (ACTION_USB_PERMISSION.equals(action))&#123;  //如果是申请权限的广播</span><br><span class="line">            final UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE); //获取到具体的某个device</span><br><span class="line">            if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,</span><br><span class="line">                    false))&#123;    //我们操作的结果，会通过这个获取到，true代表有权限，false代表无</span><br><span class="line">                if (device != null)&#123;    //进行进一步操作</span><br><span class="line">                    mDefaultListener.onSuccess(UsbPermission.this,device);//自定义的回调接口</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;    //权限申请失败回调</span><br><span class="line">                mDefaultListener.onFail(UsbPermission.this,device);//自定义的回调</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action))&#123;   //连接设备判断</span><br><span class="line">            final UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);</span><br><span class="line">            mDefaultListener.onAttach(UsbPermission.this,device); //接口回调</span><br><span class="line">            if (!mUsbManager.hasPermission(device))&#123;    //没有权限，申请权限</span><br><span class="line">                requestUsbPermission(device);  //请求usb权限</span><br><span class="line">            &#125; else &#123;    //有权限直接操作</span><br><span class="line">                mDefaultListener.onSuccess(UsbPermission.this,device);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action))&#123;    //移除设备判断</span><br><span class="line">            final UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);</span><br><span class="line">            if (device != null)&#123;    //移除设备</span><br><span class="line">                mDefaultListener.onDetach(UsbPermission.this,device);  //移除设备监听</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在我们Activity中，需要把这个广播动态注册，才能接收到广播的信息。注册方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注册监听usb设备广播</span><br><span class="line"> */</span><br><span class="line">public void register() &#123;</span><br><span class="line">    if (mPermissionIntent == null)&#123;</span><br><span class="line">        final Context context = mWeakContext.get();</span><br><span class="line">        if (context != null)&#123;</span><br><span class="line">            mPermissionIntent = PendingIntent.getBroadcast(context,0,new Intent(ACTION_USB_PERMISSION),0);</span><br><span class="line">            final IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);  //添加意图过滤USB权限申请的Action</span><br><span class="line">            filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);  //添加USB接入的Action</span><br><span class="line">            filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);  //添加USB接入的Action</span><br><span class="line">            context.registerReceiver(mUsbReceiver,filter);  //注册广播接收并添加意图过滤</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>在根据拔插设备、权限申请等，我们会很据这些事件做相应的处理，这里可以定义一些接口来做回调处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface UsbPermissionListener &#123;</span><br><span class="line">    void onSuccess(UsbPermission usbPermission, UsbDevice usbDevice);   //权限申请成功</span><br><span class="line">    void onFail(UsbPermission usbPermission, UsbDevice usbDevice);      //权限申请失败</span><br><span class="line">    void onDetach(UsbPermission usbPermission, UsbDevice usbDevice);    //usb设备连接</span><br><span class="line">    void onAttach(UsbPermission usbPermission, UsbDevice usbDevice);    //usb设备拔出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让Activity继承该接口，类比View的OnClickListener就可以进行交互了。</p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RecyclerView之自定义LayoutManager</title>
      <link href="/2017/12/19/A005/"/>
      <url>/2017/12/19/A005/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>最近在进阶研究RecyclerView。主要包括其三个抽离出来的东东，包括ItemDecoration、LayoutManager、Animator。其中ItemDecoration花费我大概一天的时间。基本上对于ItemDecoration的布局原理较为熟悉，并发布了一bolg，本打算继续学Animator，粗略看了一下，发现：哇！函数好多，好麻烦。遂罢，还是先看LayoutManager吧，常规开发仅需要定义仨方法，似乎还蛮简单的。结果！！花费了整整一周的时间。终于打通！当然，对于LayoutManager的掌握只能说较熟悉，还不是特别融会贯通。<br>通过常规的搜索，发现，</p><ol><li>其实网上对于自定义LayoutManager的文章确实比较少。</li><li>大部分都是简单对于少量数据的处理，没有涉及到回收机制，因为回收是需要自己做的。</li><li>有些较好的实例也没能由浅入深的展开。<br>因此，本篇，在google，百度过后，emmm，小小的宣称，初步学习LayoutManager，这一篇就OJBK了。<br>整片文章布局大概如下：</li><li>常规三个方法的说明，非常基础但是很重要的东西</li><li>以常规竖向滑动为例，讲解如何自定义一个LayoutManager。<a id="more"></a></li></ol><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a><center>基础</center></h3><p>本节主要是仨函数，generateDefaultLayoutParams、onLayoutChildren与scrollVerticallyBy。</p><h4 id="generateDefaultLayoutParams"><a href="#generateDefaultLayoutParams" class="headerlink" title="generateDefaultLayoutParams"></a>generateDefaultLayoutParams</h4><p>这是定义Recycler的LayoutParams，一般就是下面代码实现就可以，没啥好说的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;</span><br><span class="line">    return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, </span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mark一下，之前有在国外一个网站看到个例子，定义generateLayoutParams几个方法的，这还没研究到。国内的大部分博客都是上述代码中的做法，emmm，我也是大部分。</p><h4 id="scrollVerticallyBy"><a href="#scrollVerticallyBy" class="headerlink" title="scrollVerticallyBy"></a>scrollVerticallyBy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollVerticallyBy(int dy,//在屏幕坐标系中零碎滑动的距离。</span><br><span class="line">RecyclerView.Recycler recycler,  //回收处理用 </span><br><span class="line">RecyclerView.State state)        //Recycler状态</span><br></pre></td></tr></table></figure><ul><li>dy<br>这是滑动相关的代码，dy是断时间滑动的距离。注意：<br><strong>dy&gt;0,代表上拉！！即页面往Y坐标负方向滑动，整个界面向上！</strong><br><strong>dy&lt;0,代表下拉！！即页面往Y坐标正方向滑动，整个界面向下！</strong><br>刚开始我弄错了方向，导致很迷！！上面是我实际研究过的情况。！！</li><li>recycler<br>回收复用专用类，我们不需要考虑一个item是复用的还是重新创建的。只要问它要就好！<br>在代码中，常用几个方法：</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>detachAndScrapAttachedViews(recycler)</td><td>从屏幕上移掉，并且把item拆离开。</td></tr><tr><td>recycler.getViewForPosition(position)</td><td>从recycler获取一个item，注意！！position是在整个item中的具体位置，就是你数据里面的第几条数据的位置。</td></tr><tr><td>removeAndRecycleView(item, recycler)</td><td>移除单个item，并把它回收到recycler中。itemView是View类型的</td></tr></tbody></table><ul><li>state<br>这个方法，在google实现的LinearLayoutManager中用到，我。。没用过诶，不过它保存着一些RecyclerView的状态信息。emmm再具体就不知道了。</li></ul><h4 id="onLayoutChildren"><a href="#onLayoutChildren" class="headerlink" title="onLayoutChildren"></a>onLayoutChildren</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onLayoutChildren(RecyclerView.Recycler recycler, </span><br><span class="line"> RecyclerView.State state </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 这个方法主要是用于初始布局的。如果不调用NotifyXXX方法，只会调用俩次。至于为啥是俩次，一次布局，一次具体布局？emmm，参考文献有写。</p><h4 id="其他非常重要的方法"><a href="#其他非常重要的方法" class="headerlink" title="其他非常重要的方法"></a>其他非常重要的方法</h4><p>这里的代码也是经常会用到的:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getChildCount()</td><td>获取界面可见位置，有多少个子item。因此这个值很少，多的item被回收掉了！所以才是Recycler的View</td></tr><tr><td>addView(view),addView(view,position)</td><td>将一个获取到的item添加到屏幕可见列表上去。此时还不可见</td></tr><tr><td>measureChildWithMargins(view)</td><td>要求测量item的布局，把一个item addView之后要测量一下</td></tr><tr><td>getDecoratedMeasuredWidth()</td><td>你上面要求measure一下，就能知道它的宽高了，这里就是获取宽度具体大小，如果你不傻，就知道获取高度是啥了。这里的宽度，包含有你通过ItemDecoration装饰过的大小</td></tr><tr><td>layoutDecoratedWithMargins(view,l,t,r,b)</td><td>把addView后的item给它填充的具体的某个位置，这个位置通过ltrb确定！就是上下左右，注意！这里的上下左右，是屏幕绝对位置的坐标</td></tr><tr><td>getDecoratedTop(view)</td><td>获取view的上坐标，这里的view包含了你装饰后的尺寸，还有Left，Right，Bottom，还是只要你不傻就知道什么意思</td></tr><tr><td>offsetChildrenVertical(distance)</td><td>将整个列表移动，这里的distance，就是X0Y坐标系正常方向的位移了</td></tr></tbody></table><h3 id="一个竖直位移的带回收的列表"><a href="#一个竖直位移的带回收的列表" class="headerlink" title="一个竖直位移的带回收的列表"></a><center>一个竖直位移的带回收的列表</center></h3><p>一个列表的过程主要如下：</p><ol><li>布局</li><li>回收</li><li>填充</li><li>移动</li></ol><p>其中，布局主要有俩个地方用，1.在onLayoutChildren中第一次布局；2.在移动过程中需要不断回收和填充<br>我们将 布局，填充独立为一个layout方法。<br>将回收和移动 拆成 offset方法。</p><h4 id="layout-RecyclerView-Recycler-State"><a href="#layout-RecyclerView-Recycler-State" class="headerlink" title="layout(RecyclerView.Recycler,State)"></a>layout(RecyclerView.Recycler,State)</h4><p>首先在onLayoutChild中，我们第一次布局。这里讲解见注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (getItemCount()==0)&#123;//获取item的总数，若为0，当然不需要布局了。</span><br><span class="line">    detachAndScrapAttachedViews(recycler);//全拿掉</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">if (getChildCount()==0&amp;&amp;state.isPreLayout())&#123;//若屏幕上没有item，并且在PreLayout中会做动画效果，此时也直接返回</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">mVerticalOffset = 0;//</span><br><span class="line">mFirstPosition = 0;//能看到的第一个item具体到整个列表中的位置</span><br><span class="line">mLastPosition = getItemCount() -1;//能看到的最后一个item具体到列表中的具体位置</span><br><span class="line">detachAndScrapAttachedViews(recycler);//全拿掉，因为我们需要自己布局！</span><br><span class="line">layout(recycler,state,0);//进入到我们自己的layout方法进行布局</span><br></pre></td></tr></table></figure></p><p>下面进入到layout方法，我们只看咋初始布局的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int topOffset = getPaddingTop();</span><br><span class="line">int bottomOffset = getPaddingTop();</span><br><span class="line">if (getChildCount()&gt;0)&#123;     //如果不是第一次布局，肯定会有getChildCount&gt;0</span><br><span class="line">... //省略了一些无关代码</span><br><span class="line">&#125;else &#123;                     //如果是第一次布局，从0开始布局</span><br><span class="line">for (int i =0;i&lt;mLastPosition;i++)&#123;//遍历哦老铁,从0到能看到的最后一个位置</span><br><span class="line">View view = recycler.getViewForPosition(i);//根据整个列表中的位置，问recycler要个item的实例。</span><br><span class="line">        addView(view);    //把item添加到可见列表中</span><br><span class="line">        measureChildWithMargins(view,0,0);    //对item进行测量</span><br><span class="line">        layoutDecoratedWithMargins(view,      //将item layout到可视列表中，这里是绝对的位置</span><br><span class="line">                getPaddingLeft(),</span><br><span class="line">                topOffset,</span><br><span class="line">                getPaddingLeft()+getDecoratedMeasuredWidth(</span><br><span class="line">                topOffset+getDecoratedMeasuredHeight(view)</span><br><span class="line">        );</span><br><span class="line">        topOffset += getDecoratedMeasuredHeight(view);  //offset为，偏移距离，辅助我们排放列表</span><br><span class="line">        if (topOffset &gt; getHeight() - getPaddingBottom())&#123;</span><br><span class="line">            mLastPosition = i;    //如果偏移的位置，超过了底部边界。那么此时的i指向的就是最后一个位置</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (topOffset &lt; getHeight() - getPaddingBottom())&#123;</span><br><span class="line">        canScroll = false;        //没放满当然不可滑动了</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的过程，我们首次<strong>将item排放到屏幕上的可视区域</strong>。并且<strong>获得了</strong>屏幕中，第一个item和最后一个item对应的真实位置，即：<strong>mFirstPosition和mLastPosition</strong>。</p><p>如果不是第一次布局，则会进入下面的代码流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (getChildCount()&gt;0)&#123;     //如果不是第一次布局</span><br><span class="line">//通过下面的代码，获取当前屏幕上可视的，第一个和最后一个item真实的position</span><br><span class="line">//topOffset为最后一个item的top边界；bottomOffset为第一个item的bottom边界，这些用于做回收判断。</span><br><span class="line">    View last = getChildAt(getChildCount()-1); </span><br><span class="line">    maxPos = getPosition(last);</span><br><span class="line">    topOffset = getDecoratedBottom(last);</span><br><span class="line">    View firstView = getChildAt(0);</span><br><span class="line">    minPos = getPosition(firstView);</span><br><span class="line">    bottomOffset = getDecoratedTop(firstView);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>下面的代码，我们做填充。注意一个逻辑！<br><strong>当上拉时，我们的可视列表，头部渐渐消失在屏幕上，尾部逐渐出现在屏幕上。</strong><br>在下拉时，相反。<br><strong>因此，我们在填充的时候，需要根据偏移的距离dy，判断上拉或下拉，借此分别做填充布局。<br>如果上拉，判断最后一个item的底部在偏移dy后，是否超过底部界限，若超过，就需要在底部填充一个item，并把mLastPosition的位置+1。</strong><br>如果下拉，类比操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//滑动，填充布局</span><br><span class="line">if (dy &gt; 0)&#123;   //上拉，需要填充下面的，从最后一个位置开始填充</span><br><span class="line">    for(int i=maxPos+1;i&lt;getItemCount();i++)&#123;    </span><br><span class="line">        if (topOffset -dy &gt;getHeight() -getPaddingBottom())&#123;</span><br><span class="line">            break;  //如果偏移的 距离并不超过。直接break。不需要填充。</span><br><span class="line">        &#125;</span><br><span class="line">        View last = recycler.getViewForPosition(i);    //问recycler要一个item</span><br><span class="line">        addView(last);                                 //添加到屏幕的可见列表中</span><br><span class="line">        measureChildWithMargins(last,0,0);             //别忘了请求测量一下</span><br><span class="line">        layoutDecoratedWithMargins(last,               //然后把它layout出来</span><br><span class="line">                getPaddingLeft(),</span><br><span class="line">                topOffset,</span><br><span class="line">                getPaddingLeft() + getDecoratedMeasur</span><br><span class="line">                topOffset + getDecoratedMeasuredHeigh</span><br><span class="line">        );</span><br><span class="line">        topOffset += getDecoratedMeasuredHeight(last)</span><br><span class="line">        mLastPosition = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else if (dy &lt; 0)&#123;  //下拉，需要填充上面的，从第一个位置开始</span><br><span class="line">    for (int i=minPos-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if (bottomOffset -dy &lt;getPaddingTop())&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        View first = recycler.getViewForPosition(i);</span><br><span class="line">        addView(first,0);    //**注意！这里的addView需要我们将item添加到0位置！否则，往后步骤中通过getChildAt()方法获取到的item，并不是这个item，而是之前的item**</span><br><span class="line">        measureChildWithMargins(first,0,0);</span><br><span class="line">        layoutDecoratedWithMargins(first,</span><br><span class="line">                getPaddingLeft(),</span><br><span class="line">                bottomOffset - getDecoratedMeasuredHe</span><br><span class="line">                getPaddingLeft() + getDecoratedMeasur</span><br><span class="line">                bottomOffset</span><br><span class="line">        );</span><br><span class="line">        bottomOffset -= getDecoratedMeasuredHeight(fi</span><br><span class="line">        mFirstPosition = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上面就是布局和填充的过程。需要注意的是，填充的代码addView方法，要注意区别。</p><p> 如果，进行上拉或者下拉操作，scrollVerticallyBy方法，就会被回调，同时参数dy表明位移的距离，但是，dy这个参数可能会在边界的位置被修复，因此我们不能直接用dy来作为偏移的距离。在位移时，会调用我们自己的offset函数，接收scrollVerticallyBy的三个参数。下面为offset代码，具体解释，见代码。<br> offset函数的功能主要有俩，回收和位移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private int offset(RecyclerView.Recycler recycler, RecyclerView.State state,int dy)&#123;</span><br><span class="line">//首先计算真实的偏移距离</span><br><span class="line">    int realOffset = dy;  //realoffset为真实距离，默认为dy，需要我们重新计算</span><br><span class="line">    if (dy&lt;0)&#123;  //下拉，判断顶部是否超过边界超过修复。</span><br><span class="line">        View firstChild = getChildAt(0);    //通过界面上可见第一个item来计算是否可见</span><br><span class="line">        if (getPosition(firstChild)==0)&#123;    //只有可见的第一个item为列表中的第一个item才需要重新计算dy</span><br><span class="line">            int gap =  getDecoratedTop(firstChild) - getPaddingTop();  //gap为第一个item顶部边界与顶部边界的位移差</span><br><span class="line">            if (gap &gt;= 0)&#123;    //如果大于0，需要修复，把realOffset做反向修复。</span><br><span class="line">                realOffset = -gap;</span><br><span class="line">            &#125;else &#123;           </span><br><span class="line">            //如果小于0，取两者之间较大值，原因是，在连续的位移过程中，当头部刚被填充一个item，此时的gap值就特别小，所以仍以gap为准会导致第一个item从1突然变为0。</span><br><span class="line">                realOffset = Math.max(realOffset,gap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (dy&gt;0)&#123;    //上拉，判断底部是否超过边界</span><br><span class="line">        View lasChild = getChildAt(getChildCount() - 1);    //上拉同理，要判断最后一个item</span><br><span class="line">        if (getPosition(lasChild) == getItemCount() - 1) &#123;</span><br><span class="line">            int gap = getHeight() - getPaddingTop() - getDecoratedBottom(lasChild);</span><br><span class="line">            if (gap &gt;= 0) &#123;</span><br><span class="line">                realOffset = -gap;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                realOffset = Math.min(realOffset, -gap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //下面的代码进行回收</span><br><span class="line">    if (getChildCount()&gt;0) &#123;     //当前屏幕上有item</span><br><span class="line">    //回收针对的是可见的item，判断其在位移dy会不会被不可见，若不可见则回收。</span><br><span class="line">        for (int i = 0; i &lt; getChildCount(); i++) &#123;    //从屏幕上第一个item开始遍历。</span><br><span class="line">            View child = getChildAt(i);    //通过getChildAt(i)来获取具体的itme</span><br><span class="line">            measureChildWithMargins(child, 0, 0);</span><br><span class="line">            if (dy &lt; 0) &#123;  //下拉仅需判断下边界是否会越界</span><br><span class="line">                if (getDecoratedTop(child) - realOffset &gt; getHeight() - getPaddingBottom()) &#123;  //判断item的顶部在位移后，是否超出底部边界</span><br><span class="line">                    removeAndRecycleView(child, recycler);       //回收item</span><br><span class="line">                    mLastPosition--;                             //最后的item位置减一</span><br><span class="line">                    break;                                       //一般同时只会有一个item出界。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (dy &gt; 0) &#123;    //上拉仅需判断下边界是否越界</span><br><span class="line">                if (getDecoratedBottom(child) - realOffset &lt; getPaddingTop()) &#123;</span><br><span class="line">                    removeAndRecycleView(child, recycler);</span><br><span class="line">                    mFirstPosition++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用自定义layout方法，重新布局。</span><br><span class="line">    layout(recycler,state,realOffset);</span><br><span class="line">    mVerticalOffset += realOffset;</span><br><span class="line">    offsetChildrenVertical(-realOffset);    //调用offsetChildrenVertical进行位移，但是注意参数要取反。</span><br><span class="line">    return realOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是offset位移和回收的全部代码。因为回收之后需要重新布局，所以此时要引入layout进行布局。需要注意的有注意真实位移的计算realOffset。</p><p>本例仅为笔者在学习自定义LayoutManager中自己实现的一个layoutManager，当然能力有限，仍有欠缺，当和一些其他博文相比，还是算比较详细的。</p><h3 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a><center>博客参考</center></h3><ol><li><a href="http://blog.csdn.net/zxt0601/article/details/52948009" target="_blank" rel="noopener">【Android】掌握自定义LayoutManager(一) 系列开篇 常见误区、问题、注意事项，常用API。 - CSDN博客</a></li><li><a href="http://blog.csdn.net/lylodyf/article/details/52846602" target="_blank" rel="noopener">自定义LayoutManager的详解及其使用 - CSDN博客</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RecyclerView之ItemDecoration</title>
      <link href="/2017/12/13/A004/"/>
      <url>/2017/12/13/A004/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>RecyclerView的ItemDecoration，正如其名，是列表子项的装饰类。它其实是一个接口，方便我们对Item一些效果进行装饰。比如，常用的是添加分割线。<br>一个RecyclerView的装饰器绘制层次如下：<br><img src="https://upload-images.jianshu.io/upload_images/1638147-9e8a8158237c005c.png?imageMogr2/auto-orient/" alt="Decoration绘制层次"><br><a id="more"></a></p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a><center>重要方法</center></h3><h4 id="getItemOffsets"><a href="#getItemOffsets" class="headerlink" title="getItemOffsets"></a>getItemOffsets</h4><p>在RecyclerView的列表中，每一项占用固定的空间，当我们为其做装饰时，如果不想装饰物如分割线与Item堆叠，就需要对Item进行一定的偏移，来让装饰物填充到Item偏移后空缺出的空间。Item View的大小包含有偏移后的item大小、decoration的大小。<br>不过注意decoration仅为装饰物，在并不能在adapter中获取到item的点击事件。<br>getItemOffsets有三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>outRect</td><td>通过四个参数，指定偏移矩形的上下左右的边距。</td></tr><tr><td>parent</td><td>当前装饰器所在的RecyclerView</td></tr><tr><td>state</td><td>RecyclerView的状态</td></tr></tbody></table><p>在Google的样例中实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mOrientation == VERTICAL_LIST) &#123;</span><br><span class="line">    outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当需要的状态为Vertical即列表为竖直，我们需要为Item的底部添加装饰，那么需要将item偏移一定距离，空缺出底部用来填充底部。因此set方法的最后一个参数设置了值：mDivider.getIntrinsicWidth。</p><h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h5><p>根据RecyclerView item的绘制层次draw将在Item之前绘制，因此，item可能会遮挡这一层的视图。<br>下面是绘制分割线的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">    final int left = parent.getLeft();</span><br><span class="line">    final int right = parent.getRight();</span><br><span class="line">    final int childCount = parent.getChildCount();</span><br><span class="line">    Log.i(TAG, &quot;onDraw: &quot;+parent.getChildCount());</span><br><span class="line">    for (int i = 0; i &lt; childCount; i++)&#123;</span><br><span class="line">        final View childView = parent.getChildAt(i);</span><br><span class="line">        parent.getDecoratedBoundsWithMargins(childView,mBounds);</span><br><span class="line">        final int bottom = (int) (mBounds.bottom - childView.getTranslationY());</span><br><span class="line">        final int top = bottom - mHeight;</span><br><span class="line">            c.drawRect(left,top,right,bottom,mPaint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onDraw主要有三个参数，Canvas 用来绘制，RecyclerView parent用来获取RecyclerView的实例，RecyclerView.State state获取RecyclerView的状态。<br>获取decoration的left、top、right、bottom比较有趣。下面拿decoration在每个item的上方为例子。</p><ol><li>因为decoration在底部，所以left为parent的左边距，这里根据具体的是否包含padding来确定使用parent.getPddingLeft还是parent.getLeft。</li><li>right的位置需要考虑是否考虑padding的情况若包含padding则需要用宽度减去右padding来获取呀，即right = parent.getWidth()-parent.getPaddingRight();若不需要直接getRight即可。</li><li>不用item的高度显然是不一样的，这里使用了parent.getCount配合parent.getChidldAt(i)；循环取出每个子item。注<strong>意!这里的getCount并不是全部item，recyclerview是个循环复用的组件，所以这里的count为当前屏幕上的全部item数</strong>。通过parent.getChildAdapterPosition(view)来获取item在整个列表中的位置。</li><li>通过parent.getDecoratedBoundsWithMargins(childView,mBounds);获取装饰在item中的位置。其中，mBounds包含着这些信息。</li><li>如果decoration在底部，bottom = mBounds.bottom，top = bottom - Decoration的高度。</li><li>使用Canvas进行绘制</li></ol><h4 id="onDrawOver"><a href="#onDrawOver" class="headerlink" title="onDrawOver"></a>onDrawOver</h4><p>参考onDraw的实现，不过注意onDrawOver 绘制的位置在item的顶部，因此，它可能会遮盖onDraw层和item层。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="http://www.jianshu.com/p/b335b620af39" target="_blank" rel="noopener">【Android】RecyclerView：打造悬浮效果 - 简书</a></li><li><a href="http://www.jianshu.com/p/dda4645c824f" target="_blank" rel="noopener">Android——RecyclerView入门学习之ItemDecoration(一) - 简书</a></li><li><a href="https://blog.piasy.com/2016/03/26/Insight-Android-RecyclerView-ItemDecoration/#fn:space-needed" target="_blank" rel="noopener">深入理解 RecyclerView 系列之一：ItemDecoration - Piasy的博客 | Piasy Blog</a></li><li><a href="http://www.91display.com/api/blog/detail.do?bid=75813576148" target="_blank" rel="noopener">这篇好像很好！教你玩转 Android RecyclerView：深入解析 RecyclerView.ItemDecoration类（含实例讲解） - 91display.com - 91展示网 - 全球最大的IT技术展示网站 - 91display</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA踩的坑（一）</title>
      <link href="/2017/09/10/J002/"/>
      <url>/2017/09/10/J002/</url>
      <content type="html"><![CDATA[<h3 id="银子"><a href="#银子" class="headerlink" title="银子"></a><center>银子</center></h3><p>本系列为总结在使用JAVA进行开发过程中遇到的一些需要注意，不然容易翻车的坑。<br>本篇为List集合remove掉某一个item的问题。<br><a id="more"></a></p><h3 id="List集合remove问题"><a href="#List集合remove问题" class="headerlink" title="List集合remove问题"></a>List集合remove问题</h3><p>一般：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;java&quot;);</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">list.add(&quot;java&quot;);</span><br><span class="line">list.add(&quot;java&quot;);</span><br><span class="line">list.add(&quot;world&quot;);</span><br><span class="line">for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">if(&quot;java&quot;.equals(list.get(i)))&#123;</span><br><span class="line">list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误过程：</p><ol><li>数组指针i 遍历到 0；</li><li>发现满足”java”.equals(list.get(i)的条件，调用lsit.remove(i)；删除；数组长度-1；</li><li>此时，内部数组前移，当前list.get(i)在删除之后得到的值为hello；</li><li>i++;i的值变成1；</li><li>此时，跳过对hello的检测，直接对hello之后的“java”；进行检测；<br>为避免错误，可以采用下面几个方法：</li><li>改用迭代器进行遍历删除：<br>如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">while (iterator.hasNext())&#123;</span><br><span class="line">    String str = iterator.next();</span><br><span class="line">    if (&quot;java&quot;.equals(str))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.或者倒序遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=list.size()-1;i&gt;=0;i++)&#123;</span><br><span class="line">if(&quot;java&quot;.equals(list.get(i)))&#123;</span><br><span class="line">list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit+Rxjava封装（一）</title>
      <link href="/2017/08/18/A003/"/>
      <url>/2017/08/18/A003/</url>
      <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a><center>引子<center></center></center></h2><p>刚刚接触Retorfit和RxJava，emmm看了一些资料，同时也写了点代码。尝试总结一下，结合网上的例子，使用和风天气的api进行简单的封装，用到之前的天气预报学习的app中。</p><a id="more"></a><h2 id="Retorfit简介"><a href="#Retorfit简介" class="headerlink" title="Retorfit简介"></a><center>Retorfit简介<center></center></center></h2><p>Retorfit是 square的一个网络访问框架，面向JAVA和Android开发。使用技术动态代理和反射机制。<br>结合RxJava使用，对于我这种小白来说居然也挺爽，至少代码看起来很清楚。<br>目前很多MVP的Android代码看起来似乎都在使用Retorfit。可能也是和OkHttp是相同公司出品的+RxjAVA挺火的原因吧。</p><h2 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a><center>简单封装<center></center></center></h2><h3 id="网络权限"><a href="#网络权限" class="headerlink" title="网络权限"></a>网络权限</h3><p>在manifests中添加网络权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></pre><h3 id="gradle依赖"><a href="#gradle依赖" class="headerlink" title="gradle依赖"></a>gradle依赖</h3><p>下面是用到的全部依赖了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.0.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.0.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.0&apos;</span><br><span class="line">compile &apos;com.jakewharton:butterknife:7.0.1&apos;</span><br><span class="line">compile &apos;io.reactivex:rxjava:1.1.0&apos;</span><br><span class="line">compile &apos;io.reactivex:rxandroid:1.1.0&apos;</span><br><span class="line">compile &apos;com.jakewharton.rxbinding:rxbinding:0.4.0&apos;</span><br></pre></td></tr></table></figure></p><p>上面就是Retorfit和RxAndroid和Okhttp需要的依赖。</p><h3 id="创建api接口"><a href="#创建api接口" class="headerlink" title="创建api接口"></a>创建api接口</h3><p>我们使用的api为和风天气的接口，具体地址是</p><pre><code>https://free-api.heweather.com/v5/weather?city=苏州&amp;key=xxxxxxxxxxxxxxx</code></pre><p>  可拆分为：</p><pre><code>基地址（BASE_URL）    ：https://free-api.heweather.com/v5/偏移地址                        ：weather    请求参数（&lt;key,value&gt;）:city=苏州,key=xxxx</code></pre><p>新建一名称为WeatherService的interface类型的接口，创建getWeather方法</p><pre><code>@GET(&quot;weather&quot;)Observable&lt;HeHttpResult&gt; getWeather(@Query(&quot;city&quot;) String city,                                    @Query(&quot;key&quot;)String key);</code></pre><p>解释：</p><ol><li>接口使用了JAVA的注解机制，@GET的注解，代表了这条http请求使用了GET方法。</li><li>括弧中的（“weather”）为偏移地址，就是具体访问的功能地址</li><li>Observable<hehttpresult>，这里使用了RxJava所以使用Observable作为返回值类型，当然Retrofit也支持回调方式。尖括号中的“HeHttpResult”是接收到的Response的body数据的类型。</hehttpresult></li><li>@Query(“city”) String city，@Query是用到的参数，第一个city为键值对的key，第二个city为具体的值。</li><li>Retrofit支持@GET、@POST、@HEAD、@PUT、@DELETA、@PATCH，和参数相关的@Path、@Field、@Multipart，表示网络请求使用的请求方式具体的可以参考<a href="http://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="noopener">官方的文档</a></li></ol><h3 id="创建HttpMethods"><a href="#创建HttpMethods" class="headerlink" title="创建HttpMethods"></a>创建HttpMethods</h3><p> HttpMethods使用单例模式访问，用来负责创建Retorfit，进行相关配置。</p><ul><li>1.底层网络使用OkHttp所以要先创建OkHttpClient。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置OkHttpClient</span><br><span class="line">okHttpClient = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS).build();</span><br></pre></td></tr></table></figure><ul><li>2.创建Retorfit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建retorfit</span><br><span class="line">retrofit = new Retrofit.Builder()</span><br><span class="line">//设置okhttpclient</span><br><span class="line">.client(okHttpClient)      </span><br><span class="line">//集成Gson转换器                                    </span><br><span class="line">.addConverterFactory(GsonConverterFactory.create())   </span><br><span class="line">//集成RxJava处理     </span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) </span><br><span class="line">//设置基地址  </span><br><span class="line">    .baseUrl(WeatherService.Base_Url)                          </span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><ul><li>3.然后通过Retrofit实例化WeatherService API</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//实例化api</span><br><span class="line">weatherService = retrofit.create(WeatherService.class);</span><br></pre></td></tr></table></figure><ul><li>4.设置获取天气的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 向外暴露的获取天气的方法</span><br><span class="line">  * @param subscriber    订阅者,事件处理</span><br><span class="line">  * @param city          天气</span><br><span class="line">  */</span><br><span class="line">public void getWeather(Subscriber&lt;HeHttpResult&gt; subscriber,String city)&#123;</span><br><span class="line">String key = &quot;6c420683fae3483c80e4a3e0099fceb7&quot;;</span><br><span class="line">weatherService.getWeather(city,key)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .unsubscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整个类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HttpMethods &#123;</span><br><span class="line">    //超时</span><br><span class="line">    private static final int DEFAULT_TIMEOUT = 5;</span><br><span class="line"></span><br><span class="line">    private Retrofit retrofit = null;</span><br><span class="line">    private OkHttpClient okHttpClient = null;</span><br><span class="line">    private WeatherService weatherService = null;</span><br><span class="line"></span><br><span class="line">    private HttpMethods()&#123;</span><br><span class="line">//设置OkHttpClient</span><br><span class="line">okHttpClient = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS).build();</span><br><span class="line">//创建retorfit</span><br><span class="line">retrofit = new Retrofit.Builder()</span><br><span class="line">                .client(okHttpClient)                                       //设置okhttpclient</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())         //设置转换为Gson</span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())   //转换为RxJava</span><br><span class="line">                .baseUrl(WeatherService.Base_Url)                           //设置基地址</span><br><span class="line">                .build();</span><br><span class="line">        //实例化api</span><br><span class="line">        weatherService = retrofit.create(WeatherService.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //单例模式访问</span><br><span class="line">    private static class SingletonHolders&#123;</span><br><span class="line">        private static final HttpMethods INSTANCE = new HttpMethods();</span><br><span class="line">    &#125;</span><br><span class="line">    public HttpMethods getInstance()&#123;</span><br><span class="line">        return SingletonHolders.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 向外暴露的获取天气的方法</span><br><span class="line">     * @param subscriber    订阅者</span><br><span class="line">     * @param city          天气</span><br><span class="line">     */</span><br><span class="line">    public void getWeather(Subscriber&lt;HeHttpResult&gt; subscriber,String city)&#123;</span><br><span class="line">        String key = &quot;6c420683fae3483c80e4a3e0099fceb7&quot;;</span><br><span class="line">        weatherService.getWeather(city,key)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .unsubscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="封装代码的使用"><a href="#封装代码的使用" class="headerlink" title="封装代码的使用"></a>封装代码的使用</h3><p>创建获取天气的方法，编辑事件处理，调用HttpMethods中的方法请求天气。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 5.  6. @param weatherId</span><br><span class="line">   */</span><br><span class="line">public void requestWeather(final String weatherId)&#123;</span><br><span class="line">//创建Subscriber，订阅者</span><br><span class="line">Subscriber subscriber = new Subscriber&lt;HeHttpResult&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        Toast.makeText(WeatherActivity.this, &quot;onCompleted&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable throwable) &#123;</span><br><span class="line">             throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         @Override</span><br><span class="line">         public void onNext(HeHttpResult heHttpResult) &#123;</span><br><span class="line">         //结果显示</span><br><span class="line">             Toast.makeText(WeatherActivity.this, </span><br><span class="line">             &quot;现在的温度是：&quot;+ httpResult.getHeWeather5().get(0).getNow().getTmp(),</span><br><span class="line">              Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">//调用获取天气方法       </span><br><span class="line">HttpMethods.getInstance().getWeather(subscriber,weatherId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><center>总结<center></center></center></h2><p>以上为对Retorfit的简单封装，但是还是很多缺点：</p><ol start="6"><li>没有添加cookie </li><li>没有添加拦截器</li><li>使用方法没有良好封装</li><li>…</li></ol><p>革命之路还很远啊!!</p><h2 id="参考-amp-博文推荐"><a href="#参考-amp-博文推荐" class="headerlink" title="参考&amp;博文推荐"></a>参考&amp;博文推荐</h2><ol><li><a href="http://www.huchiwei.com/2016/09/21/%E7%9C%8B%E6%88%91%E5%BC%80%E5%8F%91%E5%B9%B2%E8%B4%A7%E9%9B%86%E4%B8%AD%E8%90%A5App%EF%BC%88%E4%B8%89%EF%BC%89-Retroft2+RxJava%E5%B0%81%E8%A3%85%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">看我开发干货集中营App（三）~Retroft2+RxJava封装使用 |<br>づHuy博客</a></li><li><a href="http://www.jianshu.com/p/29c2a9ac5abf" target="_blank" rel="noopener">Android基于Retrofit2.0+RxJava 封装的超好用的RetrofitClie… -<br>简书</a></li><li><a href="http://chuansong.me/n/463517051526" target="_blank" rel="noopener">Retrofit项目封装使用_郭霖_传送门</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJAVA </tag>
            
            <tag> Retrofit </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【转】Android学习资源网站大全</title>
      <link href="/2017/07/10/J001/"/>
      <url>/2017/07/10/J001/</url>
      <content type="html"><![CDATA[<h1 id="Android学习资源网站大全"><a href="#Android学习资源网站大全" class="headerlink" title="Android学习资源网站大全"></a>Android学习资源网站大全</h1><p>github上某个老铁整理的。。直接放到这方便我自己看。（侵删）<br>整理了一些 Android 的博客链接、学习资源网站。<strong>站在巨人的肩膀上，会看得更远</strong>。整理这一份资源也方便更多的Android开发者能享受到技术分享的力量。首先，在这里要感谢所有开源项目的作者，感谢Trinea，CodeKK，张明云，胡凯等等大大无私的技术分享，感谢所有乐于分享学习经验的人。最后，若有侵权，请联系本人，本人将及时删除侵权内容。<br><a id="more"></a></p><p>#目录</p><ul><li><a href="#官方学习资源">1.官方学习资源【推荐必看】</a></li><li><a href="#值得关注的大牛博客">2.值得关注的大牛博客</a></li><li><a href="#值得Android开发者阅读系列">3.值得 Android 开发者阅读系列【推荐必看】</a></li><li><a href="#UI自定义View">4.UI自定义View</a></li><li><a href="#性能优化">5.Android性能优化</a></li><li><a href="#单元测试系列">6.单元测试系列</a></li><li><a href="#框架相关">7.框架相关</a><ul><li><a href="#网络请求相关">网络请求相关</a></li><li><a href="#RxJava相关">RxJava相关</a></li><li><a href="#MVP/MVVM架构相关">MVP/MVVM架构相关</a></li><li><a href="#插件化开发">插件化开发</a></li></ul></li><li><a href="#高质量Android社区">8.高质量Android社区</a></li><li><a href="#开发工具第三方开源项目">9.开发工具、第三方开源项目</a></li><li><a href="#视频学习网站">10.视频学习网站</a></li><li><a href="#面试相关">11.面试相关</a></li><li><a href="#Kotlin学习">12.Kotlin学习</a> </li></ul><h2 id="优质学习资源"><a href="#优质学习资源" class="headerlink" title="优质学习资源"></a>优质学习资源</h2><ul><li><a href="http://developer.android.com/" target="_blank" rel="noopener">Android Developer</a>【推荐必看】</li><li><a href="http://androiddoc.qiniudn.com/index.html" target="_blank" rel="noopener">Android Developer (七牛镜像)</a></li><li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">Android Training 中文版</a>【推荐必看】</li><li><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="noopener">Material Design 中文版</a></li><li><a href="http://wiki.jikexueyuan.com/project/android-weekly/" target="_blank" rel="noopener">Android Weekly 中文版</a></li><li><a href="http://wiki.jikexueyuan.com/list/android" target="_blank" rel="noopener">极客学院 Wiki Android 板块</a></li><li><a href="https://chaosleong.gitbooks.io/gradle-for-android/content/" target="_blank" rel="noopener">Gradle Android Plugin 中文版</a></li><li><a href="https://github.com/googlesamples" target="_blank" rel="noopener">Google samples</a> —— Google官方Samples源码 【推荐必看】</li><li><a href="http://android-developers.blogspot.jp/" target="_blank" rel="noopener">Android Developers blog</a> —— Google官方Android博客</li></ul><h2 id="值得关注的大牛博客"><a href="#值得关注的大牛博客" class="headerlink" title="值得关注的大牛博客"></a>值得关注的大牛博客</h2><ul><li><a href="http://a.codekk.com/" target="_blank" rel="noopener">CodeKK</a> </li><li><a href="http://www.trinea.cn/" target="_blank" rel="noopener">Trinea</a> </li><li><a href="http://blog.csdn.net/Luoshengyang" target="_blank" rel="noopener">老罗的Android之旅</a> </li><li><a href="http://www.devtf.cn/" target="_blank" rel="noopener">开发技术前线</a> </li><li><a href="http://blog.csdn.net/aigestudio" target="_blank" rel="noopener">爱哥</a>  </li><li><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖</a> </li><li><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">鸿洋</a> </li><li><a href="http://hukai.me" target="_blank" rel="noopener">胡凯</a> </li><li><a href="http://www.jianshu.com/users/e6885381f7d4/latest_articles" target="_blank" rel="noopener">张明云</a></li><li><a href="http://drakeet.me" target="_blank" rel="noopener">Drakeet</a> </li><li><a href="http://wangkuiwu.github.io" target="_blank" rel="noopener">wangkuiwu</a> —— Binder、事件分发、动画解析</li><li><a href="http://www.jianshu.com/users/FK4sc4/latest_articles" target="_blank" rel="noopener">高建武</a> —— 性能优化相关文章</li><li><a href="http://blog.csdn.net/lzyzsd" target="_blank" rel="noopener">hi大头鬼hi</a> —— RxJava相关文章</li><li><a href="http://blog.csdn.net/coder_pig" target="_blank" rel="noopener">Coder-pig</a> —— 最佳入门专栏</li><li><a href="http://keeganlee.me/" target="_blank" rel="noopener">Keegan小刚</a> —— 分享了多篇Android样式的文章</li><li><a href="http://blog.csdn.net/NUPTboyZHB/" target="_blank" rel="noopener">郑海波</a> —— 文章大多与自定义控件相关</li><li><a href="http://wuxiaolong.me/" target="_blank" rel="noopener">吴小龙同学</a> —— 分享了多篇关于AndroidDesignSupportLibrary的文章</li><li><a href="http://blog.csdn.net/lincyang" target="_blank" rel="noopener">全速前行</a> —— 主讲实战技巧和平常遇到的问题</li><li><a href="http://blog.csdn.net/asce1885" target="_blank" rel="noopener">ASCE 1985</a> —— 翻译了多篇使用Kotlin开发Android应用</li><li><a href="http://blog.mcxiaoke.com" target="_blank" rel="noopener">mcxiaoke</a> —— rxjava文档，EventBus博客，多渠道打包，一些开源项目</li><li><a href="http://blog.csdn.net/wangjinyu501?viewmode=contents" target="_blank" rel="noopener">WPJY</a> —— 自定义View、开发经验</li><li><a href="http://blog.csdn.net/developer_jiangqq" target="_blank" rel="noopener">江清清的专栏</a> —— 大量实例讲解</li><li><a href="http://hujiaweibujidao.github.io" target="_blank" rel="noopener">hujiaweibujidao</a> —— 《Android开发艺术探索》读书笔记系列</li><li><a href="http://www.jianshu.com/users/b99b0edd4e77/latest_articles" target="_blank" rel="noopener">BlackSwift</a> —— 简书作者【Blur实时渲染，AnimeWallpaper】</li><li><a href="http://blog.csdn.net/qq_23547831?viewmode=contents" target="_blank" rel="noopener">Android 源码解析专栏</a></li><li><a href="http://blog.csdn.net/hejjunlin" target="_blank" rel="noopener">DriodDeveloper</a> —— 原创FrameWork源码解析，插件化研究</li></ul><h2 id="值得Android开发者阅读系列"><a href="#值得Android开发者阅读系列" class="headerlink" title="值得Android开发者阅读系列"></a>值得Android开发者阅读系列</h2><ul><li><a href="https://github.com/lizhangqu/CoreLink/blob/master/README.md" target="_blank" rel="noopener">Android 开发中的日常积累</a></li><li><a href="https://github.com/tangqi92/Android-Tips" target="_blank" rel="noopener">Android-Tips</a> —— 作者收集了大量Android开发Tip</li><li><a href="https://github.com/ZhaoKaiQiang/AndroidDifficultAnalysis" target="_blank" rel="noopener">AndroidDifficultAnalysis</a> —— 安卓开发中遇到的重难点解析，也包括平常的读书笔记和知识点整理</li><li><a href="https://will_he.gitbooks.io/android/content/" target="_blank" rel="noopener">Android 知识整理 GitBook</a></li><li><a href="https://github.com/bboyfeiyu/android-tech-frontier/wiki" target="_blank" rel="noopener">Android wiki 周刊</a></li><li><a href="https://github.com/bboyfeiyu/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">值得阅读的 Android 技术文章</a> </li><li><a href="http://bxbxbai.github.io/2014/10/07/android-develop-resource/" target="_blank" rel="noopener">整理一些比较好的 Android 开发教程</a> —— 这些都是该作者在学习Android开发过程中觉得比较好的教程和博客</li><li><a href="https://segmentfault.com/a/1190000004063006" target="_blank" rel="noopener">Segmentfault 上回答较好的一些问题</a></li><li><a href="http://www.woshipm.com/ucd/243897.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Android 界面设计视觉规范</a></li><li><a href="http://blog.zhaiyifan.cn/2016/03/14/android-new-project-from-0-p1/" target="_blank" rel="noopener">从零开始的 Android 新项目</a></li><li><a href="http://www.cloudchou.com/android/post-788.html" target="_blank" rel="noopener">深入理解 Activity 启动流程</a> </li><li><a href="http://www.jianshu.com/p/f269bcda335f" target="_blank" rel="noopener">你需要知道的 Android 拍照适配方案</a></li><li><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="noopener">Context 都没弄明白，还怎么做 Android 开发？</a></li><li><a href="https://segmentfault.com/a/1190000004676352" target="_blank" rel="noopener">Android 从开机到打开第一个应用的执行流程</a></li><li><a href="http://www.jianshu.com/p/011eb88f4e0d" target="_blank" rel="noopener">你所不知道的Android Studio调试技巧</a></li><li><a href="http://www.jianshu.com/p/1e6eed09d48b" target="_blank" rel="noopener">Android Material Design 兼容库的使用详解</a></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li><a href="http://www.trinea.cn/android/performance/" target="_blank" rel="noopener">Trinea - 性能优化系列总篇</a></li><li><a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT.html" target="_blank" rel="noopener">高建武 - 性能优化篇</a></li><li><a href="http://www.jianshu.com/p/388c693c1b58" target="_blank" rel="noopener">Android 性能优化篇</a></li><li><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">胡凯 - Android 性能优化典范</a></li><li><a href="http://www.jianshu.com/p/cdc6d2e664f1" target="_blank" rel="noopener">Android 内存泄漏总结</a></li><li><a href="http://stackoverflow.com/documentation/android/2687/memory-leaks" target="_blank" rel="noopener">stackoverflow 上的有关内存泄漏的回答</a></li><li><a href="https://zhuanlan.zhihu.com/p/24974982?utm_source=weibo&amp;utm_medium=social" target="_blank" rel="noopener">避免 Android 中 Context 引起的内存泄露</a></li><li><a href="http://www.jianshu.com/p/320eac29391a" target="_blank" rel="noopener">Apk 瘦身的几个技巧</a></li><li><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=1022&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline" target="_blank" rel="noopener">Android 性能优化典范之多线程篇</a></li><li><a href="http://zhuanlan.zhihu.com/kaede/20326073" target="_blank" rel="noopener">Android 应用性能调优的技术点</a></li><li><a href="http://blog.tingyun.com/web/article/detail/155" target="_blank" rel="noopener">Android 客户端性能优化</a></li></ul><h2 id="UI自定义View"><a href="#UI自定义View" class="headerlink" title="UI自定义View"></a>UI自定义View</h2><ul><li><a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">安卓自定义View教程目录</a></li><li><a href="http://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">Android自定义控件三部曲文章索引</a></li><li><a href="http://blog.csdn.net/wingichoy/article/details/50483101" target="_blank" rel="noopener">简单说说Android自定义view学习推荐的方式</a></li><li><a href="https://github.com/D-clock/AndroidSystemUiTraining" target="_blank" rel="noopener">Android System UI Training</a></li><li><a href="https://gold.xitu.io/post/58ad9ca70ce463006b24f134" target="_blank" rel="noopener">Android 状态栏操作，你想知道的都在这里了</a></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><a href="http://www.cnblogs.com/starstone/p/4890409.html" target="_blank" rel="noopener">HTTP 必知必会</a> —— 【推荐必看】</li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">In Introduction to HTTP Basics</a> ——【推荐必看】</li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-okhttp/" target="_blank" rel="noopener">OkHttp：Java 平台上的新一代HTTP客户端</a> —— 【推荐必看】</li><li><a href="https://zhuanlan.zhihu.com/p/27040041" target="_blank" rel="noopener">HTTPS 原理浅析及其在 Android 中的使用</a> —— 【推荐必看】</li><li><a href="https://zhuanlan.zhihu.com/p/22816331" target="_blank" rel="noopener">Android安全开发之安全使用HTTPS</a> —— 【推荐必看】</li><li><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a> —— 【推荐必看】</li><li><a href="https://realm.io/news/droidcon-jake-wharton-simple-http-retrofit-2/" target="_blank" rel="noopener">Retrofit 2 用法解析</a></li><li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="noopener">OkHttp3 源码分析</a></li><li><a href="http://blog.csdn.net/nugongahou110/article/details/46829605" target="_blank" rel="noopener">Volley 源码分析</a></li><li><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="noopener">Android网络请求心路历程</a> —— 【推荐必看】</li><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="noopener">理解 RESTful架构</a></li><li><a href="http://www.jianshu.com/p/93f8c9ae8819" target="_blank" rel="noopener">RxJava与Retrofit的封装</a></li><li><a href="http://www.jianshu.com/p/9c3b4ea108a7" target="_blank" rel="noopener">使用 Retrofit 和 Okhttp 实现网络缓存</a> </li><li><a href="http://www.jianshu.com/p/7e28c8216c7d" target="_blank" rel="noopener">RxJava 处理网络连接失败</a></li><li><a href="http://www.jianshu.com/p/584707554ed7" target="_blank" rel="noopener">Android 推送技术研究</a></li><li><a href="http://www.jianshu.com/p/77d418e7b5d6" target="_blank" rel="noopener">OkHttp, Retrofit, Volley 应该选择哪一个？</a></li><li><a href="http://blog.csdn.net/qq_21430549/article/details/51212977" target="_blank" rel="noopener">Retrofit 文件上传下载</a></li><li><a href="http://www.jianshu.com/p/93153b34310e" target="_blank" rel="noopener">Android Retrofit 2.0 使用-补充篇</a></li><li><a href="http://www.jianshu.com/p/d410911be40c" target="_blank" rel="noopener">谈谈移动应用的安全性实践 - 网络篇</a></li></ul><h2 id="RxJava相关"><a href="#RxJava相关" class="headerlink" title="RxJava相关"></a>RxJava相关</h2><ul><li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">Rxjava 详解</a> —— 抛物线出品经典Rxjava详解 【推荐必看】</li><li><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="noopener">深入浅出 Rxjava</a> —— rx教父大头鬼出品深入浅出rxjava</li><li><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="noopener">Awesome-RxJava</a> —— rx教父大头鬼整理的Rxjava学习集合</li><li><a href="https://github.com/mcxiaoke/RxDocs" target="_blank" rel="noopener">RxDocs-RxJava 文档中文版</a></li><li><a href="http://wangxinghe.me/blog/2016-03-27/rxjava-basis/" target="_blank" rel="noopener">RxJava 学习总结</a></li><li><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a></li><li><a href="https://medium.com/@diolor/improving-ux-with-rxjava-4440a13b157f#.9mc2oeyzo" target="_blank" rel="noopener">Improving UX with RxJava</a></li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/index.html" target="_blank" rel="noopener">ReactiveX 文档中文翻译</a></li><li><a href="http://www.jianshu.com/p/c2c7c46e6b97" target="_blank" rel="noopener">使用 RxBinding 响应控件的异步事件</a></li><li><a href="http://www.jianshu.com/p/6d1ef9f43cdc" target="_blank" rel="noopener">详细解析 RxAndroid 的使用方式</a></li><li><a href="http://www.jianshu.com/p/f3f0eccbcd6f" target="_blank" rel="noopener">RxJava简洁封装之道</a></li></ul><h2 id="MVP-MVVM架构相关"><a href="#MVP-MVVM架构相关" class="headerlink" title="MVP/MVVM架构相关"></a>MVP/MVVM架构相关</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a> —— 【推荐必看】</li><li><a href="http://www.jianshu.com/p/1f21e1d375aa" target="_blank" rel="noopener">不容错过，最全的 Android 架构合集</a></li><li><a href="http://www.jianshu.com/p/0590f530c617" target="_blank" rel="noopener">Android MVP 详解</a></li><li><a href="http://www.judymax.com/archives/1141?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Google官方 MVP 案例 todoAPP 解析</a></li><li><a href="http://www.jianshu.com/p/6872b699879d" target="_blank" rel="noopener">Android MVVM 框架</a></li><li><a href="http://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger2 详解</a></li><li><a href="http://www.jianshu.com/collection/b838b070d6de?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=collection&amp;utm_source=weibo" target="_blank" rel="noopener">Android Dagger2 系列</a></li><li><a href="http://www.jianshu.com/p/01d3c014b0b1" target="_blank" rel="noopener">Google官方 MVP + Dagger2 架构详解</a></li></ul><h2 id="插件化开发"><a href="#插件化开发" class="headerlink" title="插件化开发"></a>插件化开发</h2><ul><li><a href="http://www.androidblog.cn/index.php/Index/detail/id/16" target="_blank" rel="noopener">插件化开发专栏</a> —— 有关插件化的资料这里全都有</li></ul><h2 id="单元测试系列"><a href="#单元测试系列" class="headerlink" title="单元测试系列"></a>单元测试系列</h2><ul><li><a href="http://rexstjohn.com/unit-testing-with-android-studio/" target="_blank" rel="noopener">unit-testing-with-android-studio</a></li><li><a href="http://www.jianshu.com/p/9d988a2f8ff7" target="_blank" rel="noopener">Robolectric3.0 介绍</a></li><li><a href="http://www.jianshu.com/p/b2717dc245da" target="_blank" rel="noopener">Android 单元测试: 首先，从是什么开始</a> —— 小创出品【推荐必看】</li><li><a href="http://www.jianshu.com/p/4b03123b4f81" target="_blank" rel="noopener">在 Android 中同时使用 unit test 和 instrument test 作为单元测试</a></li><li><a href="http://www.jianshu.com/p/fa76b126a7e7" target="_blank" rel="noopener">Android 单元测试——辅助工具介绍</a></li><li><a href="http://www.jianshu.com/p/00ab03f3d394" target="_blank" rel="noopener">Android 单元测试实践</a></li><li><a href="http://www.jianshu.com/p/cf446be43ae8" target="_blank" rel="noopener">解读 Android 官方 MVP 项目单元测试</a></li><li><a href="http://tech.meituan.com/Android_unit_test.html" target="_blank" rel="noopener">美团 Android 单元测试研究与实践</a></li></ul><h2 id="高质量Android社区"><a href="#高质量Android社区" class="headerlink" title="高质量Android社区"></a>高质量Android社区</h2><ul><li><a href="http://gank.io/post/published" target="_blank" rel="noopener">Gank.io 匠心写作</a></li><li><a href="https://www.diycode.cc/sites" target="_blank" rel="noopener">Android 开发者酷站</a></li><li><a href="http://xueandroid.com/index" target="_blank" rel="noopener">鸿洋的 Android 社区</a> —— 全是干货</li><li><a href="http://stackoverflow.com/questions/tagged/android" target="_blank" rel="noopener">Stackoverflow</a> —— 国外著名的问答社区</li><li><a href="http://antonioleiva.com" target="_blank" rel="noopener">antoniolevia</a> —— 国外android技术分享网站</li><li><a href="http://www.androidweekly.cn" target="_blank" rel="noopener">Android 开发技术周报</a> —— 长期更新最新前言资讯</li><li><a href="http://www.devtf.cn/" target="_blank" rel="noopener">开发技术前线</a> —— 《Android源码设计模式》作者 Mr.Simple 维护的社区网站</li><li><a href="http://gank.io" target="_blank" rel="noopener">干货集中营</a> —— 每日分享妹子图 和 技术干货，还有供大家中午休息的休闲视频</li><li><a href="http://bugly.qq.com/bbs/forum.php?mod=forumdisplay&amp;fid=39" target="_blank" rel="noopener">腾讯 bugly 社区</a> </li><li><a href="http://gold.xitu.io/explore/android" target="_blank" rel="noopener">掘金 Android</a></li><li><a href="https://www.v2ex.com/go/android" target="_blank" rel="noopener">V2ex-Android</a></li></ul><h2 id="开发工具第三方开源项目"><a href="#开发工具第三方开源项目" class="headerlink" title="开发工具第三方开源项目"></a>开发工具第三方开源项目</h2><ul><li><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a> —— Android各种开发工具、SDK、资源</li><li><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="noopener">Android 开源项目分类汇总</a> —— 史上最全的Android开源项目汇总</li><li><a href="http://app.memect.com/doc/android.html" target="_blank" rel="noopener">Android 资源库列表</a> —— 一个超级棒的安卓资源库列表</li><li><a href="http://www.oschina.net/question/2285044_219206?fromerr=gEGePPMG" target="_blank" rel="noopener">最强开发资源平台大合集</a> —— 各种UI图标库、工具集</li><li><a href="http://www.materialpalette.com" target="_blank" rel="noopener">MD 调色板</a></li><li><a href="https://icomoon.io/app/#/select" target="_blank" rel="noopener">Icon 图标</a> —— 各种icon图标</li><li><a href="http://www.flaticon.com" target="_blank" rel="noopener">图标下载库</a> —— 160,428 vector icons grouped in 2,409 packs</li><li><a href="https://github.com/l123456789jy/Lazy" target="_blank" rel="noopener">一些常用的开发工具类</a></li></ul><h2 id="视频学习网站"><a href="#视频学习网站" class="headerlink" title="视频学习网站"></a>视频学习网站</h2><ul><li><a href="http://chinagdg.org/google-videos/" target="_blank" rel="noopener">Google 官方性能优化视频</a> —— GDG中译版</li><li><a href="http://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></li><li><a href="http://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li><li><a href="http://www.maiziedu.com/" target="_blank" rel="noopener">麦子学院</a></li><li><a href="https://www.udacity.com/courses/android" target="_blank" rel="noopener">Udacity Google 官方视频教程</a></li></ul><h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><ul><li><a href="https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="noopener">国内一线互联网公司内部面试题库</a></li><li><a href="http://mianbajun.sinaapp.com" target="_blank" rel="noopener">Android 面霸君</a></li><li><a href="http://kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></li><li><a href="http://www.diycode.cc/wiki/androidinterview" target="_blank" rel="noopener">Android 开发工程师面试指南 Wiki</a></li><li><a href="http://blog.csdn.net/mc_hust/article/details/49517915" target="_blank" rel="noopener">很详细的 Android 工程师面试题大全</a></li><li><a href="https://github.com/android-cn/android-discuss/issues" target="_blank" rel="noopener">Android-discuss，可以作为面试题参考</a></li><li><a href="http://www.jianshu.com/p/1bdf7d0e1ac5" target="_blank" rel="noopener">Android 工程师面试题大全</a></li><li><a href="http://www.jianshu.com/p/5f6d79323923" target="_blank" rel="noopener">快速了解 Android 重要机制</a></li><li><a href="https://www.zhihu.com/question/30070178/answer/92849985" target="_blank" rel="noopener">知乎上回答的腾讯面经</a></li><li><a href="http://www.jianshu.com/p/f0d2ed1254a9" target="_blank" rel="noopener">BAT 无线工程师面试流程详细解析</a></li><li><a href="http://www.jianshu.com/p/d1efe2f31b6d" target="_blank" rel="noopener">史上最全 Android 面试资料集合</a></li><li><a href="http://www.bingjie.me/2016/05/12/扫清面试前的准备.html" target="_blank" rel="noopener">冰姐 - 扫清 Android 面试障碍–面试前的准备</a></li><li><a href="https://www.zybuluo.com/Yano/note/321063" target="_blank" rel="noopener">Java 虚拟机面试题全面解析</a></li><li><a href="http://www.jianshu.com/p/69141aa52f34?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="noopener">关于 Android 性能、架构和技术问题的探索</a></li></ul><h2 id="Kotlin学习"><a href="#Kotlin学习" class="headerlink" title="Kotlin学习"></a>Kotlin学习</h2><ul><li><a href="https://juejin.im/post/591dd9f544d904006c9fbb96" target="_blank" rel="noopener">Kotlin 资源大全 - 学 Kotlin 看这个就够了</a></li><li><a href="http://www.liying-cn.net/kotlin/docs/reference/" target="_blank" rel="noopener">Kotlin 参考文档</a></li><li><a href="https://github.com/mcxiaoke/awesome-kotlin" target="_blank" rel="noopener">awesome-kotlin</a> </li></ul>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSON解析以及GSON简明使用</title>
      <link href="/2017/03/28/A002/"/>
      <url>/2017/03/28/A002/</url>
      <content type="html"><![CDATA[<p><img src="http://o7iipar59.bkt.clouddn.com//source/A002-8.jpg" alt="json头图"></p><h2 id="何为JSON"><a href="#何为JSON" class="headerlink" title="何为JSON"></a><center>何为JSON</center></h2><p><a href="https://zh.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">JSON</a>为JavaScript Object Notation的简称，是一种用于轻量级的数据交换语言，是用了存储和交换文本信息的语法。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式，目前很多主流的编程语言都支持JSON。<br>说到JSON就不得不提到xml，与XML想比，JSON占用更小、速度更快，更易解析。JSON不可用于配置文件，仅仅作为传输信息来使用。<br><a id="more"></a></p><h2 id="JSON基本语法规则"><a href="#JSON基本语法规则" class="headerlink" title="JSON基本语法规则"></a><center>JSON基本语法规则</center></h2><p>下面是几个JSON中的基本也是最重要的概念<del>，JSON也就这几个概念</del>。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>一个对象一个对象以<strong>{开始，并以}</strong>结束。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSON另外一个常用的概念是数组，在键值对中的值或者对象中有时候并不可能是一个简单的值，有时候则可能是数组。数组或有序列表，使用<strong>[，]</strong>来表示。</p><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>在对象中通常包含不止一个<strong>“键-值”对</strong>。键值对以<strong>{“名称”:”值”}</strong>的形式书写，如果是多对键值对则用<strong>，</strong>分隔。键值对的一个名称是一个字符串； 一个值可以是一个字符串，一个数值，一个对象，一个布尔值，一个有序列表，或者一个null值。</p><hr><h2 id="JSON基本解析实例"><a href="#JSON基本解析实例" class="headerlink" title="JSON基本解析实例"></a><center>JSON基本解析实例</center></h2><h3 id="一个简单的小例子"><a href="#一个简单的小例子" class="headerlink" title="一个简单的小例子"></a>一个简单的小例子</h3><p>这里是我从wiki中直接拿过来的一个例子，我觉得非常的好，就拿来直接用。这是一个名为 Jhon Smith的“电话簿”。我们一行行来看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;//①最外层是一个JSON对象，&#123;&#125;中间的为这个对象的内容。</span><br><span class="line"> &quot;firstName&quot;: &quot;John&quot;,  //②一个键值对，名称为firstName,值为John，用逗号隔开键值对</span><br><span class="line">     &quot;lastName&quot;: &quot;Smith&quot;,  //同②，略</span><br><span class="line">     &quot;sex&quot;: &quot;male&quot;,        //同②，略</span><br><span class="line">     &quot;age&quot;: 25,            //同②，略</span><br><span class="line">     &quot;address&quot;:  //③一个键值对，名称为address，值为一JSON对象</span><br><span class="line">     &#123;</span><br><span class="line">         &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,  //同②，略</span><br><span class="line">         &quot;city&quot;: &quot;New York&quot;,                //同②，略</span><br><span class="line">         &quot;state&quot;: &quot;NY&quot;,                     //同②，略</span><br><span class="line">         &quot;postalCode&quot;: &quot;10021&quot;              //同②，略</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;phoneNumber&quot;://④一个键值对，名称为phoneNumber，但是值是JSON数组。</span><br><span class="line">     [  //⑤这里是数组的开始，数组的大小为2，内容为2个对象，数组元素之间使用，隔开。</span><br><span class="line">         &#123;  //⑥数组中第一个元素，为一JSON对象</span><br><span class="line">           &quot;type&quot;: &quot;home&quot;,</span><br><span class="line">           &quot;number&quot;: &quot;212 555-1234&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           &quot;type&quot;: &quot;fax&quot;,</span><br><span class="line">           &quot;number&quot;: &quot;646 555-4567&quot;</span><br><span class="line">         &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>既然文章叫做JSON解析，上面都是论述，总得有个具体的解析吧，那么下面我使用JAVA来常识解析上面的小例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA中json包的引用我就不说了。</span></span><br><span class="line">String json=response.body().string;  <span class="comment">//假设从服务拿出来的json字符串，就是上面的内容</span></span><br><span class="line">JSONObject personObj = <span class="keyword">new</span> JSONObject(json); <span class="comment">//①创建一个名为person的JSONObject类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//②下面分别取出 最外层JSONObject包裹的firstName、lastName等字符串</span></span><br><span class="line">System.out.println(personObj.getString(<span class="string">"firstName"</span>));</span><br><span class="line">System.out.println(personObj.getString(<span class="string">"lastName"</span>));</span><br><span class="line">System.out.println(personObj.getString(<span class="string">"sex"</span>));</span><br><span class="line">System.out.println(personObj.getInt(<span class="string">"age"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//③下面是取出 最外层JSONObject包裹的名称为address的JSONObject</span></span><br><span class="line">JSONObject addressObj = personObj.getJSONObject(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//④下面是取出 addressObject中的streetAddress等对应的字符串</span></span><br><span class="line">System.out.println(addressObj.getString(<span class="string">"streetAddress"</span>);</span><br><span class="line">System.out.println(addressObj.getString(<span class="string">"city"</span>);</span><br><span class="line">System.out.println(addressObj.getString(<span class="string">"state"</span>);</span><br><span class="line">System.out.println(addressObj.getString(<span class="string">"postalCode"</span>);</span><br><span class="line"><span class="comment">//⑤下面是取出 最外层JSONObject包裹的名称为phoneNumber的JSONArray</span></span><br><span class="line">JSONArray phoneNumberArray = personObj.getJSONArry(<span class="string">"phoneNumber"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//⑥下面是利用循环 读取phoneNumberArray 中的信息</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; phoneNumberArray.lenth(); i++)&#123;</span><br><span class="line">JSONObject tempObj = phoneNumberArray.getJSONObject(i);</span><br><span class="line">System.ouy.println(tempObj.getString(<span class="string">"type"</span>));</span><br><span class="line">System.ouy.println(tempObj.getString(<span class="string">"number"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a><center>实例</center></h2><h3 id="和风天气api返回json结果"><a href="#和风天气api返回json结果" class="headerlink" title="和风天气api返回json结果"></a>和风天气api返回json结果</h3><p>这里的实例引用了和风天气api的例子，和风天气的是我做课程作业需要使用到的，也是我接触的第一个实际开发过程中使用的例子。<br>这是我直接从服务器拿回来的json的数据，我第一次看，感觉十分的复杂 - -。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;HeWeather5&quot;:[&#123;&quot;aqi&quot;:&#123;&quot;city&quot;:&#123;&quot;aqi&quot;:&quot;66&quot;,&quot;pm10&quot;:&quot;82&quot;,&quot;pm25&quot;:&quot;38&quot;,&quot;qlty&quot;:&quot;良&quot;&#125;&#125;,&quot;basic&quot;:&#123;&quot;city&quot;:&quot;常熟&quot;,&quot;cnty&quot;:&quot;中国&quot;,&quot;id&quot;:&quot;CN101190402&quot;,&quot;lat&quot;:&quot;31.658156&quot;,&quot;lon&quot;:&quot;120.74852&quot;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2017-04-04 16:51&quot;,&quot;utc&quot;:&quot;2017-04-04 08:51&quot;&#125;&#125;,&quot;daily_forecast&quot;:[&#123;&quot;astro&quot;:&#123;&quot;mr&quot;:&quot;11:41&quot;,&quot;ms&quot;:&quot;00:51&quot;,&quot;sr&quot;:&quot;05:42&quot;,&quot;ss&quot;:&quot;18:19&quot;&#125;,&quot;cond&quot;:&#123;&quot;code_d&quot;:&quot;104&quot;,&quot;code_n&quot;:&quot;305&quot;,&quot;txt_d&quot;:&quot;阴&quot;,&quot;txt_n&quot;:&quot;小雨&quot;&#125;,&quot;date&quot;:&quot;2017-04-04&quot;,&quot;hum&quot;:&quot;61&quot;,&quot;pcpn&quot;:&quot;0.0&quot;,&quot;pop&quot;:&quot;0&quot;,&quot;pres&quot;:&quot;1020&quot;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;20&quot;,&quot;min&quot;:&quot;15&quot;&#125;,&quot;uv&quot;:&quot;7&quot;,&quot;vis&quot;:&quot;16&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;141&quot;,&quot;dir&quot;:&quot;东南风&quot;,&quot;sc&quot;:&quot;微风&quot;,&quot;spd&quot;:&quot;5&quot;&#125;&#125;,&#123;&quot;astro&quot;:&#123;&quot;mr&quot;:&quot;12:41&quot;,&quot;ms&quot;:&quot;01:45&quot;,&quot;sr&quot;:&quot;05:41&quot;,&quot;ss&quot;:&quot;18:20&quot;&#125;,&quot;cond&quot;:&#123;&quot;code_d&quot;:&quot;104&quot;,&quot;code_n&quot;:&quot;305&quot;,&quot;txt_d&quot;:&quot;阴&quot;,&quot;txt_n&quot;:&quot;小雨&quot;&#125;,&quot;date&quot;:&quot;2017-04-05&quot;,&quot;hum&quot;:&quot;75&quot;,&quot;pcpn&quot;:&quot;2.3&quot;,&quot;pop&quot;:&quot;71&quot;,&quot;pres&quot;:&quot;1015&quot;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;20&quot;,&quot;min&quot;:&quot;16&quot;&#125;,&quot;uv&quot;:&quot;8&quot;,&quot;vis&quot;:&quot;14&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;145&quot;,&quot;dir&quot;:&quot;南风&quot;,&quot;sc&quot;:&quot;微风&quot;,&quot;spd&quot;:&quot;3&quot;&#125;&#125;,&#123;&quot;astro&quot;:&#123;&quot;mr&quot;:&quot;13:41&quot;,&quot;ms&quot;:&quot;02:32&quot;,&quot;sr&quot;:&quot;05:40&quot;,&quot;ss&quot;:&quot;18:20&quot;&#125;,&quot;cond&quot;:&#123;&quot;code_d&quot;:&quot;306&quot;,&quot;code_n&quot;:&quot;305&quot;,&quot;txt_d&quot;:&quot;中雨&quot;,&quot;txt_n&quot;:&quot;小雨&quot;&#125;,&quot;date&quot;:&quot;2017-04-06&quot;,&quot;hum&quot;:&quot;81&quot;,&quot;pcpn&quot;:&quot;7.5&quot;,&quot;pop&quot;:&quot;100&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;22&quot;,&quot;min&quot;:&quot;13&quot;&#125;,&quot;uv&quot;:&quot;5&quot;,&quot;vis&quot;:&quot;10&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;189&quot;,&quot;dir&quot;:&quot;东北风&quot;,&quot;sc&quot;:&quot;微风&quot;,&quot;spd&quot;:&quot;7&quot;&#125;&#125;],&quot;hourly_forecast&quot;:[&#123;&quot;cond&quot;:&#123;&quot;code&quot;:&quot;100&quot;,&quot;txt&quot;:&quot;晴&quot;&#125;,&quot;date&quot;:&quot;2017-04-04 19:00&quot;,&quot;hum&quot;:&quot;62&quot;,&quot;pop&quot;:&quot;0&quot;,&quot;pres&quot;:&quot;1019&quot;,&quot;tmp&quot;:&quot;17&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;142&quot;,&quot;dir&quot;:&quot;东南风&quot;,&quot;sc&quot;:&quot;3-4&quot;,&quot;spd&quot;:&quot;18&quot;&#125;&#125;,&#123;&quot;cond&quot;:&#123;&quot;code&quot;:&quot;103&quot;,&quot;txt&quot;:&quot;晴间多云&quot;&#125;,&quot;date&quot;:&quot;2017-04-04 22:00&quot;,&quot;hum&quot;:&quot;72&quot;,&quot;pop&quot;:&quot;0&quot;,&quot;pres&quot;:&quot;1018&quot;,&quot;tmp&quot;:&quot;16&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;148&quot;,&quot;dir&quot;:&quot;东南风&quot;,&quot;sc&quot;:&quot;3-4&quot;,&quot;spd&quot;:&quot;18&quot;&#125;&#125;],&quot;now&quot;:&#123;&quot;cond&quot;:&#123;&quot;code&quot;:&quot;104&quot;,&quot;txt&quot;:&quot;阴&quot;&#125;,&quot;fl&quot;:&quot;18&quot;,&quot;hum&quot;:&quot;49&quot;,&quot;pcpn&quot;:&quot;0&quot;,&quot;pres&quot;:&quot;1019&quot;,&quot;tmp&quot;:&quot;19&quot;,&quot;vis&quot;:&quot;8&quot;,&quot;wind&quot;:&#123;&quot;deg&quot;:&quot;144&quot;,&quot;dir&quot;:&quot;东南风&quot;,&quot;sc&quot;:&quot;3-4&quot;,&quot;spd&quot;:&quot;16&quot;&#125;&#125;,&quot;status&quot;:&quot;ok&quot;,&quot;suggestion&quot;:&#123;&quot;air&quot;:&#123;&quot;brf&quot;:&quot;中&quot;,&quot;txt&quot;:&quot;气象条件对空气污染物稀释、扩散和清除无明显影响，易感人群应适当减少室外活动时间。&quot;&#125;,&quot;comf&quot;:&#123;&quot;brf&quot;:&quot;舒适&quot;,&quot;txt&quot;:&quot;白天不太热也不太冷，风力不大，相信您在这样的天气条件下，应会感到比较清爽和舒适。&quot;&#125;,&quot;cw&quot;:&#123;&quot;brf&quot;:&quot;不宜&quot;,&quot;txt&quot;:&quot;不宜洗车，未来24小时内有雨，如果在此期间洗车，雨水和路上的泥水可能会再次弄脏您的爱车。&quot;&#125;,&quot;drsg&quot;:&#123;&quot;brf&quot;:&quot;较舒适&quot;,&quot;txt&quot;:&quot;建议着薄外套、开衫牛仔衫裤等服装。年老体弱者应适当添加衣物，宜着夹克衫、薄毛衣等。&quot;&#125;,&quot;flu&quot;:&#123;&quot;brf&quot;:&quot;易发&quot;,&quot;txt&quot;:&quot;相对于今天将会出现大幅度降温，空气湿度较大，易发生感冒，请注意适当增加衣服。&quot;&#125;,&quot;sport&quot;:&#123;&quot;brf&quot;:&quot;较适宜&quot;,&quot;txt&quot;:&quot;阴天，较适宜进行各种户内外运动。&quot;&#125;,&quot;trav&quot;:&#123;&quot;brf&quot;:&quot;适宜&quot;,&quot;txt&quot;:&quot;天气较好，风稍大，但温度适宜，总体来说还是好天气。这样的天气适宜旅游，您可以尽情享受大自然的风光。&quot;&#125;,&quot;uv&quot;:&#123;&quot;brf&quot;:&quot;最弱&quot;,&quot;txt&quot;:&quot;属弱紫外线辐射天气，无需特别防护。若长期在户外，建议涂擦SPF在8-12之间的防晒护肤品。&quot;&#125;&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用工具格式化"><a href="#使用工具格式化" class="headerlink" title="使用工具格式化"></a>使用工具格式化</h3><p>当我使用<a href="https://c.runoob.com/front-end/53" target="_blank" rel="noopener">工具</a>将这串字符格式化后更加清晰可读了。<br><img src="http://o7iipar59.bkt.clouddn.com//source/A002-3.jpg" alt="JSON格式化后"></p><p>从图中可以看出清楚的看出整个和风天气json的结构，左边是格式化后代码，右边是一个树状图结构。<br>首先在整个结构的最外层是一个键值对，名称为HeWeather5（因为是x5版本），值为一JSON数组类型且这个数组仅含有一个JSONObject类型的元素。<br>接着，在这个JSONObject下面有7个键值对，名称分别是”aqi”（城市空气质量状况），”basic”（城市基础信息），”daily_forecast”（三天的日预报），”hourly_forecast”（每小时的预报），”now”（现在的天气情况），”status”（返回消息的状态），”suggestion”（建议信息）。他们对应着或是几组JSONObject或是JSONArray信息的值，甚至再接着嵌套多次信息。那么我们只要根据形势进行相应的展开就好了。<br><strong>下面</strong>，我将做示范。<br>别想了！这个嵌套我要写老久<del>，我好菜</del>。明天试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//占坑</span><br></pre></td></tr></table></figure></p><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><center>拓展</center></h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>那么，当处理这些json嵌套的时候，首先要进行对数据的建模，然后解开这些嵌套，然后把相应的值给填进去。但当我们遇到一个更复杂的json时，这个工作就很是繁琐，所以下面就引入了很是方便的办法。</p><h3 id="GSON使用"><a href="#GSON使用" class="headerlink" title="GSON使用"></a>GSON使用</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。<br>下面是我在Android 中使用GSON根据上述的和风天气的例子，进行解析的过程。</p><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>首先使用GSON需要导包，因为使用Android Studio的原因，只需要在app的gradle中的dependencies依赖中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.google.code.gson:gson:2.7&apos;</span><br></pre></td></tr></table></figure></p><h4 id="创建POJO类"><a href="#创建POJO类" class="headerlink" title="创建POJO类"></a>创建POJO类</h4><p>接着根据实际，需要创建<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener">POJO</a>类，根据分析后的json代码，当我们把第一层解开后，其实是一个JSONObject嵌套6个JSONObject和一个键值对的情况。那么我们根据实际需要（用到什么取什么或者是全取），取了aqi，basic等对应的5几个JSONObject类。下面单独拿出来几个进行讲解。</p><blockquote><p>例子①</p></blockquote><p>这边是经过格式化和tree化的aqi相关的json原码，注意两个红框处。<br><img src="http://o7iipar59.bkt.clouddn.com//source/A002-4.png" alt="aqi"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①Aqi.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aqi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AqiCity city;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AqiCity</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String aqi;</span><br><span class="line">        <span class="keyword">public</span> String pm25;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，创建一个POJO类，其中仅有一个，名为city的内部类AqiCity成员变量，其中内部类AqiCity有两个公有变量：aqi和pm25。</p><p>总结一下，<strong>每当JSONObject的内部有一个JSONObject，就需要在POJO类内部创建一个内部类并添加一个相应成员变量，该成员变量名应该和json键值对的键名相一致</strong>。</p><p>下面这个图可以粗略的看出对应关系。<br><img src="http://o7iipar59.bkt.clouddn.com//source/A002-5.png" alt="json与pojo类对应关系"></p><blockquote><p>例子②</p></blockquote><p>这边是经过格式化和tree化的basic相关的json原码，注意两个红框处。<br><img src="http://o7iipar59.bkt.clouddn.com//source/A002-6.png" alt="basic"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//②Basic.java</span><br><span class="line">public class Basic &#123;</span><br><span class="line">    @SerializedName(&quot;city&quot;)</span><br><span class="line">    public String cityName;</span><br><span class="line">    </span><br><span class="line">    @SerializedName(&quot;id&quot;)</span><br><span class="line">    public String weatherId;</span><br><span class="line">    </span><br><span class="line">    public Update update;</span><br><span class="line">    public class Update&#123;</span><br><span class="line">        @SerializedName(&quot;loc&quot;)</span><br><span class="line">        public String UpdateTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在例子①中POJO类的变量名称和json的键值对的名称都是一样的，那么在上面的例子中，并不对应，那么这时就需要使用注解的方式：添加一个<code>@SerializedName(&quot;city&quot;)</code>进行注解。<br>但是如果我如果是不同服务器发出的json，仅仅只是键名不同，那么我的POJO类又该怎么处理呢？那么将注解这样写：</p><pre><code>@SerializedName(value = &quot;cityName&quot;, alternate = {&quot;cityname&quot;, &quot;city_name&quot;})</code></pre><p>总之就是，<strong>如果 POJO对象/变量 想要和json中不一致，就需要注解</strong>。</p><blockquote><p>例子③</p></blockquote><p>这边是经过格式化的json原码，注意两个红框处。<br><img src="http://o7iipar59.bkt.clouddn.com//source/A002-7.jpg" alt="weather"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//③Weather.java</span><br><span class="line">public class Weather &#123;</span><br><span class="line">    public String status;</span><br><span class="line">    public Basic basic;</span><br><span class="line">    public Aqi aqi;</span><br><span class="line">    public Now now;</span><br><span class="line">    public Suggestion suggestion;</span><br><span class="line">    @SerializedName(&quot;daily_forecast&quot;)</span><br><span class="line">    public List&lt;Forecast&gt; forecastList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Weather.java是将这6个JSONObject和1个键值对嵌套在一起的POJO类，但是我们在嵌套的时候，又会遇到一个问题：daily_forecast对应的是一个JSONArray，JSONArray的每一个元素又是一个JSONObject这时候应该怎么做呢？<br>根据上面的代码，可以看出这里使用了List&lt;&gt;，使用java的list的泛型来构造。即，<strong>JSONArray型变量需要使用List创建并根据元素类型，选择是否要用泛型</strong>。</p><p>总结三点:</p><ol><li><strong>每当JSONObject的内部有一个JSONObject，就需要在POJO类内部创建一个内部类并添加一个相应成员变量，该成员变量名应该和json键值对的键名相一致。</strong></li><li><strong>如果 POJO对象/变量 想要和json中不一致，就需要注解。</strong></li><li><strong>JSONArray型变量需要使用List创建并根据元素类型，选择是否要用泛型。</strong></li></ol><h4 id="JSON转化为GSON"><a href="#JSON转化为GSON" class="headerlink" title="JSON转化为GSON"></a>JSON转化为GSON</h4><p>最后，只需要将获取的json转化为gson就可以了，这里用到了gson的fromJson方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Weather handleWeatherResponse(String response)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">    //因为最外面仍有一个JSONObject所以，只需要手动把它解开接行了</span><br><span class="line">    JSONObject jsonObject = new JSONObject(response);</span><br><span class="line">    JSONArray jsonArray = jsonObject.getJSONArray(&quot;HeWeather5&quot;);</span><br><span class="line">    String weatherContent = jsonArray.getJSONObject(0).toString();</span><br><span class="line">    //fromJson方法需要包含两个参数，第一个为json代码，第二个为创建的POJO类</span><br><span class="line">    return new Gson().fromJson(weatherContent,Weather.class);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果正常，这个函数就会返回一个Weather类型的值，此时我们需要的参数都包含在里面了！</p><h3 id="One-More-Thing-Gsonformat"><a href="#One-More-Thing-Gsonformat" class="headerlink" title="One More Thing : Gsonformat"></a>One More Thing : Gsonformat</h3><ol><li>重复大量的POJO创建工作是一件很伤脑经的事情，这里我们引入一个Android Studio的插件：Gsonformat，使用它就可以很方便的构造模型。<br>这里不做过多叙述了，<a href="http://blog.csdn.net/dreamlivemeng/article/details/51262538" target="_blank" rel="noopener">点击这个链接查看Gsonformat的配置以及使用</a>。</li><li>本篇博文参考<a href="http://www.jianshu.com/p/e740196225a4" target="_blank" rel="noopener">你真的会用Gson吗?Gson使用指南（一） - 简书</a>。是一篇非常好的参考gson使用指南。</li><li><a href="http://www.jianshu.com/p/6f5f818afe4b?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">推荐几款实用的Android Studio 插件 - 简书</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JAVA </tag>
            
            <tag> JSON </tag>
            
            <tag> GSON </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中 从arrays.xml读取资源（string、drawable等）</title>
      <link href="/2017/03/22/A001/"/>
      <url>/2017/03/22/A001/</url>
      <content type="html"><![CDATA[<h4 id="引用arrays-xml中的String资源"><a href="#引用arrays-xml中的String资源" class="headerlink" title="引用arrays.xml中的String资源"></a>引用arrays.xml中的String资源</h4><p>在res/values文件夹下创建一个数组，创建的数组如下所示<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arrays.xml</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string-array name=<span class="string">"places"</span>&gt;</span><br><span class="line">        &lt;item&gt;安徽宏村&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;安徽黄山&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;福建武夷山&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;福建霞浦&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;甘肃省敦煌市鸣沙山和月牙泉&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;开平碉楼&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;广西阳朔&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;贵州黄果树瀑布&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;海南南山海上观音像&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;海南省亚龙湾&lt;/item&gt;</span><br><span class="line">    &lt;/string-array&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Java代码中获取数组并使用"><a href="#Java代码中获取数组并使用" class="headerlink" title="Java代码中获取数组并使用"></a>Java代码中获取数组并使用</h4><p>在java中使用的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private String[] items;</span><br><span class="line">items = getResources().getStringArray(R.array.places);</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="引用arrays-xml中的Drawable资源"><a href="#引用arrays-xml中的Drawable资源" class="headerlink" title="引用arrays.xml中的Drawable资源"></a>引用arrays.xml中的Drawable资源</h4><p>如果数组中的资源为图片资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;string-array name=&quot;pic&quot;&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p1&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p2&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p3&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p4&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p5&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p6&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p7&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p8&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p9&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;@drawable/p10&lt;/item&gt;</span><br><span class="line">&lt;/string-array&gt;</span><br></pre></td></tr></table></figure></p><h4 id="获取并使用Drawable资源"><a href="#获取并使用Drawable资源" class="headerlink" title="获取并使用Drawable资源"></a>获取并使用Drawable资源</h4><p>则java中获取的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypedArray pic = getResources().obtainTypedArray(R.array.pic);</span><br><span class="line">//！！使用方法1：</span><br><span class="line">Drawable drawable = pic.getDrawable(i);//获取第i个Drawable类型的值。</span><br><span class="line">//!!使用方法2：</span><br><span class="line">int id = pic.getResourcesId(i,-1);//获取第i个drawable 的id，默认为-1</span><br></pre></td></tr></table></figure></p><h4 id="很重要的-注意！"><a href="#很重要的-注意！" class="headerlink" title="很重要的 注意！"></a>很重要的 注意！</h4><blockquote><p>注意！在使用drawable的时候，我起初采用上述的方法1来进行从arrays.xml中读取数组，但是我发现，在我做Activity跳转的时候，<strong>传递Drawable类型是很头疼的事情！</strong>采用Intent的方法传递，并不支持Drawable类型。为此你就需要先将Drawable类型转化为Bitmap类型，通过Bitmap来进行传递。然鹅，Bitmap仅仅支持<strong>40kb</strong>的内容！并且伤心的是我的图超过40kb，果然AS就报错了- -，所以就在想要不要用数据流啥的传输。另外一个页面里解一下。<br><strong>等等，</strong><br>既然我的drawable已经是在数组中了，我为何不<strong>用drawable的id来进行传输</strong>？传递个int类型总可以了吧。而且是int类型不需要传递这么长的数据来耗费资源。<br>所以就找到了<strong>getResourceId(int i,int def)；</strong>这个函数。为此，我要再次强调一下这个方法的使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//①从array数组读取自己想要的数组资源，这里是pic，并赋值给TypedArray类型的pic</span><br><span class="line">TypedArray pic = getResources().obtainTypedArray(R.array.pic);</span><br><span class="line">//②使用getResourceId方法获取id,i为第i个元素，-1为默认值。传给id</span><br><span class="line">int id = pic.getResourceId(i,-1);</span><br><span class="line">//③为ImageView设置图片</span><br><span class="line">img.setImgResources(id);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个哈希加密算法</title>
      <link href="/2017/02/23/my-poor-C/"/>
      <url>/2017/02/23/my-poor-C/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><center>概述</center></h2><p>上午CAo4给我一个很小（大概有40行）的python程序，让我帮着用C重写。本以为很简单，没想到一直写啊写，就用了一天的时间。<del>果然我是个渣</del>。然后想到了博客似乎很久很久没更新了，借此机会重新总结点东西吧，也不枉我今天花费了这么长时间。<br>本篇博客主要是一些关于C语言和python语言很零碎的知识点。算是基础知识。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><center>正文</center></h2><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><p>下面是python源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># python</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">/* pwdhash为加密后的密码。key为关键字 */</span><br><span class="line">def crack_zhengfang( pwdhash, key=&quot;Encrypt01&quot; ):</span><br><span class="line">  len_passwd = len( pwdhash )</span><br><span class="line">  len_key = len( key )</span><br><span class="line">/* pwdhash密码前一半与后一半倒序拼接 */</span><br><span class="line">  pwdhash = pwdhash[: len_passwd/2][::-1] + pwdhash[len_passwd/2 :][::-1]</span><br><span class="line">  passwd = &apos;&apos;</span><br><span class="line">  Pos = 0</span><br><span class="line">/*哈希加密，key为关键字的长度，循环长度为关键字长度</span><br><span class="line">** strChar = 转换后pwdhash的第i位</span><br><span class="line">** KeyChar = 关键字的第Pos-1位</span><br><span class="line">** 如果strChar和KeyChar的ascii转为int类型后，按位异或不在32和126之间或者strChar的int值不在0到255之间，则密码加一位strChar。否则密码加一位strChar与KeyChar按位异或转为ascii码。</span><br><span class="line">*/</span><br><span class="line">  for i in xrange( len_passwd ):</span><br><span class="line">      Pos %= len_key</span><br><span class="line">      Pos += 1</span><br><span class="line">      strChar = pwdhash[i]</span><br><span class="line">      KeyChar = key[Pos-1]</span><br><span class="line">      ord_strChar = ord( strChar )</span><br><span class="line">      ord_KeyChar = ord( KeyChar )</span><br><span class="line">      if not 32 &lt;= ( ord_strChar ^ ord_KeyChar ) &lt;= 126 or not 0 &lt;= ord_strChar &lt;= 255:</span><br><span class="line">          passwd += strChar</span><br><span class="line">      else:</span><br><span class="line">          passwd += chr( ord_strChar ^ ord_KeyChar )</span><br><span class="line">  return passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  if len(sys.argv) != 2:</span><br><span class="line">    print &quot;Usage: crackZF.py passwdhash&quot;</span><br><span class="line">    sys.exit(1)</span><br><span class="line">  else:</span><br><span class="line">    print &quot;Password:&quot;, crack_zhengfang( pwdhash=sys.argv[1], key=&quot;Encrypt01&quot; )</span><br></pre></td></tr></table></figure></p><h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><p>下面是我写的C…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">char * left(char *dst, char *src, int n)</span><br><span class="line">&#123;</span><br><span class="line">char *p = src;</span><br><span class="line">char *q = dst;</span><br><span class="line">int len = strlen(src);</span><br><span class="line">if (n&gt;len) n = len;</span><br><span class="line">q =q+n-1;</span><br><span class="line">while (n--) *(q--) = *(p++);</span><br><span class="line">q = dst;</span><br><span class="line">q += n;</span><br><span class="line">*(q++) = &apos;\0&apos;;</span><br><span class="line">return dst;</span><br><span class="line">&#125;</span><br><span class="line">char * right(char *dst, char *src, int n)</span><br><span class="line">&#123;</span><br><span class="line">char *p = src;</span><br><span class="line">char *q = dst;</span><br><span class="line">int len = strlen(src);</span><br><span class="line">if (n&gt;len) n = len;</span><br><span class="line">p = p+len-1;</span><br><span class="line">while (n--) *(q++) = *(p--);</span><br><span class="line">*(q++) = &apos;\0&apos;;</span><br><span class="line">return dst;</span><br><span class="line">&#125;</span><br><span class="line">char *crack(char* pwdhash, char* key)</span><br><span class="line">&#123;</span><br><span class="line">    int len_passwd = strlen(pwdhash);</span><br><span class="line">int len_key = strlen(key);</span><br><span class="line">char *tmp1 = (char*)calloc(1,5);</span><br><span class="line">char *tmp2 = (char*)calloc(1,5);</span><br><span class="line">*tmp1 = &quot;&quot;;</span><br><span class="line">*tmp2 = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">tmp1 = strcpy(tmp1,left(tmp1, pwdhash, len_passwd / 2));</span><br><span class="line">tmp2 = strcpy(tmp2,right(tmp2, pwdhash, len_passwd / 2));</span><br><span class="line"></span><br><span class="line">    pwdhash = (char*)malloc(strlen(tmp1)+strlen(tmp2)+1);</span><br><span class="line">    char *p = pwdhash;</span><br><span class="line">    char *c = tmp1;</span><br><span class="line">    char *d = tmp2;</span><br><span class="line">    while(*c!=&apos;\0&apos;) *(p++)=*(c++);</span><br><span class="line">    while(*d!=&apos;\0&apos;) *(p++)=*(d++);</span><br><span class="line">    *(p++)=&apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">char * passwd = (char*)calloc(1,100);</span><br><span class="line">char *pp = passwd;</span><br><span class="line">int Pos = 0, i;</span><br><span class="line">for (i = 0; i &lt;len_passwd; i++)</span><br><span class="line">&#123;</span><br><span class="line">Pos %= len_key;</span><br><span class="line">Pos += 1;</span><br><span class="line">char strCahr = pwdhash[i];</span><br><span class="line">char keyChar = key[Pos - 1];</span><br><span class="line">int ord_strChar = (int)strCahr;</span><br><span class="line">int ord_KeyChar = (int)keyChar;</span><br><span class="line">if (!((32 &lt;= (ord_strChar ^ ord_KeyChar)&amp;&amp; (ord_strChar ^ ord_KeyChar) &lt;= 126) ) ||!((0 &lt;= ord_strChar&amp;&amp; ord_strChar &lt;= 255)))</span><br><span class="line">        &#123;</span><br><span class="line">            *pp = strCahr;</span><br><span class="line">            pp++;</span><br><span class="line">            *(pp+1)=&apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">else</span><br><span class="line">        &#123;</span><br><span class="line">            *pp= toascii(ord_KeyChar ^ord_strChar);</span><br><span class="line">            pp++;</span><br><span class="line">            *(pp+1)=&apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">return passwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">char *pwdhash,*rec;</span><br><span class="line">rec =(char*)malloc(100);</span><br><span class="line"></span><br><span class="line">    if(argc==2)</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(rec,argv[1]);</span><br><span class="line">        pwdhash = (char*)malloc(strlen(rec)+1);</span><br><span class="line">        strcpy(pwdhash,rec);</span><br><span class="line">        char *key = &quot;Encrypt01&quot;;</span><br><span class="line">        printf(&quot;passwd is:%s\n&quot;, crack(pwdhash, key));</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Only accept one parameter!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C语言-一些基本语法"><a href="#C语言-一些基本语法" class="headerlink" title="C语言 一些基本语法"></a>C语言 一些基本语法</h3><p>python代码重写为C后代码行增加了一倍。Python真是个简洁高效的语言。整个过程浪费的主要时间在C语言的指针上，指针这种东西真是种超越神一般的存在！！</p><ol><li>C语言中的字符串类型可以通过下面的方法定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* a = &quot;&quot;;</span><br><span class="line">char* b = &quot;123&quot;;</span><br><span class="line">char c[4] = &quot;1234&quot;;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是C是一种静态编程语言，下面这种是不合法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char d[] = &quot;12345&quot;;错误×</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串<strong>在字符串定义赋值后，其内存空间大小就已经固定了！</strong><br>所以下面这种情况也是错误的!</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* a = &quot;&quot;;</span><br><span class="line">char* b = &quot;123&quot;;</span><br><span class="line">strcpy(a,b);错误x,a的内存溢出！</span><br></pre></td></tr></table></figure><p>所以在使用字符串进行操作的时候要注意其内存的，在标准库中，我们可以使用malloc、calloc与realloc函数对内存进行操作。<a href="https://openhome.cc/Gossip/CGossip/MallocFree.html" target="_blank" rel="noopener">这里是相关知识的介绍。</a><br>3.字符串的一系列操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这些操作主要有：</span><br><span class="line">strcpy(p, p1) 复制字符串 </span><br><span class="line">strncpy(p, p1, n) 复制指定长度字符串 </span><br><span class="line">strcat(p, p1) 附加字符串 </span><br><span class="line">strncat(p, p1, n) 附加指定长度字符串 </span><br><span class="line">strlen(p) 取字符串长度 </span><br><span class="line">strcmp(p, p1) 比较字符串 </span><br><span class="line">strcasecmp忽略大小写比较字符串</span><br><span class="line">strncmp(p, p1, n) 比较指定长度字符串 </span><br><span class="line">strchr(p, c) 在字符串中查找指定字符 </span><br><span class="line">strrchr(p, c) 在字符串中反向查找 </span><br><span class="line">strstr(p, p1) 查找字符串</span><br></pre></td></tr></table></figure></p><p><a href="https://www.byvoid.com/zhs/blog/c-string" target="_blank" rel="noopener">下面是具体操作实例的链接</a>。</p><p>  <strong>当我们进行操作的时候还是要仔细注意内存空间的分配。</strong></p><ol start="4"><li>其他<br>字符串的结尾一定是’\0’，所以才有sizeof与strlen相差1。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *a = &quot;&quot;;</span><br><span class="line">char *b = &quot;123&quot;;</span><br><span class="line">a = (char* )malloc(strlen(b)+1);//malloc返回void类型所以要转换类型。</span><br><span class="line">strcpy(a,b);</span><br></pre></td></tr></table></figure><p>注意下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char * left(char *dst, char *src, int n)</span><br><span class="line">&#123;</span><br><span class="line">char *p = src;</span><br><span class="line">char *q = dst;</span><br><span class="line">int len = strlen(src);</span><br><span class="line">if (n&gt;len) n = len;</span><br><span class="line">q =q+n-1;</span><br><span class="line">while (n--) *(q--) = *(p++);</span><br><span class="line">q = dst;</span><br><span class="line">q += n;</span><br><span class="line">*(q++) = &apos;\0&apos;;//很重要</span><br><span class="line">//printf(&quot;%s\n&quot;, dst);</span><br><span class="line">return dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针和q指针分别指向src和dst指针指向的内存区域。如果我们直接对字符串dst和src进行操作，其指向的位置就会发生更改，则又会出现内存问题。所以<strong>我们不能对字符串指针直接操作</strong>，只能先创建指向这个位置的指针，然后通过指针来操作字符串。<br>同时在*(q++) = ‘\0’;<strong>在字符串的末尾需要添加’\0’才会是一个完整的字符串</strong>。否则一些相关的操作诸如strcat无法进行操作，会发生内存泄漏。在VS中我们会见到一些输入strcat_s、prinf_s的函数，都会指定缓存区域的大小，有效避免了这个问题。</p><ol start="5"><li><p>C语言char类型与int类型转换（ascii转化为int类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ascii转化为int：</span><br><span class="line">char c =&apos;c&apos;;</span><br><span class="line">int i = (int)c;//i = 99;</span><br><span class="line">int 转化为 ascii:</span><br><span class="line">char c = &apos;\99&apos; = &apos;c&apos;</span><br></pre></td></tr></table></figure></li><li><p>main()函数的argc和argv<br>之前学习的时候，main函数并没有带有参数，如果是linux C，或者是需要命令行运行的程序，就可能涉及到带参运行的问题。下面是个实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,argc);</span><br><span class="line">while(argc--) printf(&quot;%s &quot;,argv[argc]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">D:\AndroidProj\helloe\bin\Debug\helloe.exe</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 0.823 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure></p><p>可知，argc代表了后面参数的个数，argv[0]代表程序本身，argv[1]代表第一个参数，以此类推。</p><h3 id="Python的一些基本语法"><a href="#Python的一些基本语法" class="headerlink" title="Python的一些基本语法"></a>Python的一些基本语法</h3><ol><li>Python的字符串截取<br><a href="http://blog.csdn.net/win_turn/article/details/52998912" target="_blank" rel="noopener">这个博客写的很详细</a></li><li>Pyhon字符串操作<br><a href="https://my.oschina.net/golang/blog/209208" target="_blank" rel="noopener">这个博客写的很详细</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>龙芯中断</title>
      <link href="/2016/06/12/third/"/>
      <url>/2016/06/12/third/</url>
      <content type="html"><![CDATA[<p><img src="http://o7iipar59.bkt.clouddn.com/10.jpg" alt="龙芯中断"><br><a id="more"></a></p><h3 id="中断架构"><a href="#中断架构" class="headerlink" title="中断架构"></a>中断架构</h3><h4 id="CPU核感知中断"><a href="#CPU核感知中断" class="headerlink" title="CPU核感知中断"></a>CPU核感知中断</h4><p>CPU核能接收到的中断必须在Cause寄存器中能够显示出来。所以要让CPU接收到中断。一定要直接连到IP0-IP7这八个位的输入口。Cause寄存器定义如下：</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/3-1.png" alt="图 1.1Cause寄存器定义"><br>IP0~IP7 用于标识发生了哪些中断。IP0 和IP1 是软件中断位，不提供对外的中断引脚。IP2~IP5随着硬件输入引脚上的信号而变化，标识哪些设备发生了中断。IP6 用于处理器核间中断，负责多核处理器的通信。IP7 一方面用于MIPS 内部的定时器中断，另一方面用于性能计数器中断    这些中断也可以通过设置SR寄存器的IM0~IM7位进行屏蔽，SR寄存器的定义如下：</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/3-2.png" alt="图1.2 SR寄存器的定义"></p><h4 id="外部中断路由"><a href="#外部中断路由" class="headerlink" title="外部中断路由"></a>外部中断路由</h4><p>对于具体的CPU核来说，中断可以分为两类：外部的中断和内部的中断。内部中断就是在IP2-IP5之外的引脚输入的中断，包括IPI，软件中断，时钟中断。外部中断主要是指右外设引发的中断。<br>下面是中断路由模块的示意图：</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/3-3.png" alt="图1.3 中断路由模块"><br>可以看到这个配合模块的输入是32个中断源，配置的就是这些中断路由到哪个CPU核的哪个IP位。但是这里核旁边的IP0~IP3实际对应了CAUSE寄存器的IP2~IP5。南北桥所有的中断都是通过HT打头的中断引脚传入。</p><h4 id="HT外部设备中断"><a href="#HT外部设备中断" class="headerlink" title="HT外部设备中断"></a>HT外部设备中断</h4><p>现在的3A产品中，已经遇到的设备除了串口，都是从HT转过来的。流程如下：首先南桥的中断控制器在接收到中断申请后，会发出中断请求，经过PCIE的root complex转化后发送到HT总线，然后被HT总线得知，HT控制器自动询问中断控制器是IRQ几，然后设置自己的中断状态寄存器。之后按照配置发出HT-1 INT0之类的中断，然后这个引脚连接到COU的中断路由控制模块，路由到某个CPU核。</p><h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p>3A的中断控制器位于南桥上，可以设置成APIC或者是8259A模式，但是CPU不支持的原因只能使用8269模式。PCIE设备的中断有两种方式，INTx emulation和MSI。MSI也是需要CPU支持的所以3A只能使用INTx emulation方式。<br>因为PCIE没有中断引脚，中断不能通过一个线上的直接电平变化表示，所以虚拟INTx中断也是通过包的方式发出的。中断包的路由目标就是南桥上的中断控制器，中断首先会到达root complex，然后路由到中断控制器。下面是一个南北桥设备的中断通路示意图：</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/3-4.png" alt="图2.1南北桥设备的中断通路示意图"><br>南桥的中断控制器共有10个输入：INTA#~INTH#（8个），SCI，SMBus interrupt。中断控制器在接收到中断包就会知道虚拟中断号（INTx），具体的向上层发送的中断号是可以配置的。IRQ号从0~15。具体如下图所示：</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/3-5.png" alt="图2.2 中断控制器的路由配置"><br>这个路由的配置是听过IO的0XC00，0XC01这两个端口。具体的就是要往0XC00写值来表示配置哪个中断输入，二胺后写0XC01表示这个输入要发往哪个IRQ号。例如：<br>    将INTC#上传的中断设置为IRQ6操作如下：<br>        ①：2 → 0XC00<br>        ②：6 → 0XC01</p><h3 id="HT控制器的接收和上传中断"><a href="#HT控制器的接收和上传中断" class="headerlink" title="HT控制器的接收和上传中断"></a>HT控制器的接收和上传中断</h3><p>现在所有外设的触发中断都被8259管理，无论是通过INTx emulation还是SCI。8259能上抛的中断就是IRQ0~IRQ15，中断要传给CPU，必须通过HT总线，而HT总线的一端在龙芯CPU的HT控制器上，另一端在北桥的HT接口上。北桥的HT接口一般称为HTIU，一般通过PCIE的bus0 device0fun0寄存器进行操作的。所以中断应该是通过北桥的root complex 转化8259上抛的中断实现的，通过HT接口上抛的是HT格式的中断包。</p><p>3A有两个HT控制器，接收root complex转换的8259中断申请的是和北桥相连的HT控制器，这里应该是HT1，HT0用于核间中断。</p><p>每个HT控制器可以接收256个中断。就HT IRQ0 ~ HT IRQ255.这里256个中断分为8组，每组32个，第一组为HT IRQ0 ~ HT IRQ31。每组中断在物理上都是通过一个引脚出去连接到3ACPU的中断路由模块。对于HT1控制器，这八个中断引脚在手册中名为HT1 int0 ~HT1 int7。其实，8259的IRQ0~IRQ15就是HT控制器的HT IRQ0~HT IRQ15。<br>8259即PIC，8259 上来的中断都被分在HT 中断的第一组，送到CPU。内部的都是HT1 INT0 这个引脚。所以在中断控制器是8259 而不是APIC 的情况下，HT 外设备上来的中断无论如何配置，必然路由到同一个核中。</p>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO相关 </tag>
            
            <tag> MIPS异常与中断 </tag>
            
            <tag> APIC </tag>
            
            <tag> PIC </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>I/O设备和中断相关</title>
      <link href="/2016/06/05/article2/"/>
      <url>/2016/06/05/article2/</url>
      <content type="html"><![CDATA[<p><img src="http://o7iipar59.bkt.clouddn.com/8.jpg" alt="I/O设备和中断相关"><br><a id="more"></a></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="何为中断"><a href="#何为中断" class="headerlink" title="何为中断"></a>何为中断</h4><p>所谓中断，是指在CPU正常运行的过程中，由在执行的于某个外部或内部事件，导致CPU停止当前正在运行的程序，转去处理该事件，等到时间处理结束之后再返回到被中断的程序中继续运行。<br>中断是提高计算机性能的一种设计，在没有中断的时候，每个设备都需要等待其他设备，造成资源的浪费。</p><h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><p>对于一般的X86与ARM，按照CPU和中断源（能够把提出中断请求的设备和时间成为中断源）可分为内部中断和外部中断。<br>内部中断：也称异常中断，属于非屏蔽中断，是处理器检测到异常情况或执行软件中断指令引起的一种中断。通常有：除法出错中断（INT0）、断点中断（INT3）、溢出中断（INT4）和但不执行中断（INT1）等。异常又分为故障和陷阱。<br>外部中断：也称硬件中断。是由CPU外部引脚出发的一种中断，分为不可屏蔽NMI(INT2)和可屏蔽中断（INTR）<br>对于MIPS结构来说，MIPS将中断归在异常之中。MIPS的异常称为“精确异常”，因为异常是执行指令时同步发生的，因此，在造成异常的指令之前执行的指令，无疑是有效的。然而由于MIPS的高度流水线体系结构，在引起异常的指令时，后面一条指令已经完成了读取和译码的准备工作，只需要ALU空闲处理。当异常发生时，这些预备工作就被废弃。CPU从异常中返回时，就再重新做读取和译码的工作。因此，我们可以保证，在异常发生时，异常指令之后的所有指令都不会被执行。这样就不需要在MIPS的异常处理例程中为延时槽指令而烦恼了。</p><h4 id="龙芯（MIPS）的异常"><a href="#龙芯（MIPS）的异常" class="headerlink" title="龙芯（MIPS）的异常"></a>龙芯（MIPS）的异常</h4><p>找到了一张图用来理解龙芯的异常感觉十分准确，如下图所示。从图中可以看出龙芯的整个异常处理是个树状结构。这张图对应的是2E处理器，对于3B处理器，大概也差不多。</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/2-1.png" alt="图1.1 龙芯异常处理"></p><h3 id="IO和中断"><a href="#IO和中断" class="headerlink" title="IO和中断"></a>IO和中断</h3><h4 id="轮询方式"><a href="#轮询方式" class="headerlink" title="轮询方式"></a>轮询方式</h4><p>轮询方式是早期计算机系统对IO设备的一种管理方式，典型的用途就是在那些任务比较单一的单片机上，在嵌入式系统也有应用。<br>它 定时的 对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。<br>轮询的一种典型的实现可能是这样的：while(TRUE){/<em>…</em>/ select(,,timeout); /<em>…</em>/};当然这里的select()也可以使用poll()替换。</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><p>目前大部分的设备都采用中断的方式与CPU进行交互，中断不需要处理器轮询设备的状态，设备在自己发生状态改变时将主动发送一个信号给处理器（PIC），后者在接收到这一通知信号时，会挂起当前正在执行的任务转而去处理响应外设的中断请求。中断通知机制通过硬件信号异步唤起处理器的注意，解决了外部设备与处理器之间速度不匹配导致的资源浪费问题。<br>处理器在中断到达时会根据不同的中断号找到对应设备（IRR），并对中断请求进行响应处理。中断处理例程ISR（Interrupt Service Routine）由设备驱动程序提供，并在设备驱动模块初始化时注册到系统中断向量表中。从设备发出中断信号，到处理器最终调用ISR进行处理，期间会经过很多步骤，这个过程构成了中断处理框架。<br>在I/O设备中断方式下，中央处理器与I/O设备之间数据的传输步骤如下： </p><ol><li>在某个进程需要数据时，发出指令启动输入输出设备准备数据。</li><li>在进程发出指令启动设备之后，该进程放弃处理器，等待相关I/O操作完成。此时，进程调度程序会调度其他就绪进程使用处理器。 </li><li>当I/O操作完成时，输入输出设备控制器通过中断请求线向处理器发出中断信号，处理器收到中断信号之后，转向预先设计好的中断处理程序，对数据传送工作进行相应的处理。</li><li>得到了数据的进程，转入就绪状态。在随后的某个时刻，进程调度程序会选中该进程继续工作。</li></ol><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>DMA（Direct Memory Access），直接内存存取技术是指，数据在内存与I/O设备间直接进行成块传输。内存与IO之间传送一个数据块的过程中，不需要CPU的任何中间干涉，只需要CPU在过程开始的时候向设备发出“传送块数据”的命令，然后通过终端来得知是否结束和下次操作是否就绪。<br>DMA工作过程 ：</p><ol><li>当进程要求设备输入数据时，CPU把准备存放输入数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器。</li><li>发出数据传输要求的进行进入等待状态。此时正在执行的CPU指令被暂时挂起。进程调度程序调度其他进程占据CPU。</li><li>输入设备不断地窃取CPU工作周期，将数据缓冲寄存器中的数据源源不断地写入内存，直到所要求的字节全部传送完毕。</li><li>DMA控制器在传送完所有字节时，通过中断请求线发出中断信号。CPU在接收到中断信号后，转入中断处理程序进行后续处理。</li><li>中断处理结束后，CPU返回到被中断的进程中，或切换到新的进程上下文环境中，继续执行。</li></ol><h3 id="PIC和APIC"><a href="#PIC和APIC" class="headerlink" title="PIC和APIC"></a>PIC和APIC</h3><h4 id="PIC概念"><a href="#PIC概念" class="headerlink" title="PIC概念"></a>PIC概念</h4><p>PIC(Programmable Interrupt Control)可编程中断控制器，通常是指使用两片Intel8259A级联所构成的最多支持15个中断向量的中断控制系统。每个8259A可处理多达 8 个不同的 IRQ。下面是PIC级联图。</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/2-2.jpg" alt="图3.1 二级8259A级联"></p><h4 id="PIC相关"><a href="#PIC相关" class="headerlink" title="PIC相关"></a>PIC相关</h4><p>在MIPS架构中，需要经过下面步骤：</p><ol><li>设置或屏蔽相关寄存器。</li><li>进入异常入口点取指。</li><li>现场保护。</li><li>异常分类（MIPS下中断也是一种异常）处理。</li><li>查找中断向量表路由ISR。</li></ol><p>不同的操作系统对中断处理框架的设计不尽相同，但是要达到的目的是一样的，那就是最终调用用户注册的设备ISR。<br>在数字逻辑电路层面，外部设备和处理器之间有一条专门的中断信号线（Interrupt Line），用于连接外设与CPU的中断引脚（Interrupt Pin）。当外部设备发生状态改变时，可以通过这条信号线向处理器发出一个中断请求（Interrupt Request，IRQ）,其中外部设备通常被称作中断源（Interrupt Source）。<br>处理器一般只有两根左右的中断引脚（例如8259A的INTR和INTA），而管理的外设却很多。为了解决这个问题，现代设备的中断信号线并不是与处理器直接相连，而是与一个称为中断控制器的设备相连接，后者才跟处理器的中断引脚连接。中断控制器一般可以通过处理器进行编程配置，所以常称为可编程中断控制器PIC（Programmable Interrupt Controller）。下图是一个典型的中断硬件连接的系统框架图：<br> <img src="http://o7iipar59.bkt.clouddn.com/source/2-3.png" alt="中断硬件连接系统架构图"></p><h4 id="中断连接框图"><a href="#中断连接框图" class="headerlink" title="中断连接框图"></a>中断连接框图</h4><p>PIC的输出中断信号线连接到处理器的INT引脚上，这是处理器专门用来接收中断信号的pin脚。外部设备的中断线连接到PIC的pin引脚上，这是PIC用来接收外设中断的pin脚。比如第一个设备的中断线通过P0连到PIC上。在实际的硬件平台上，PIC有的在CPU外部，比如x86平台的8259中断控制器；有的被封装到CPU的内部，这广泛见于嵌入式领域。一颗SoC芯片内部集成了处理器和各种外部设备的控制器，其中包括PIC。<br>IRQ相关信息管理的关键点是一个全局数组，每个数组项对应一个IRQ编号，软件中断号irq就是这个数组的索引，irq将一对一或多对一（共享）映射到硬件中断源编号。</p><h4 id="APIC"><a href="#APIC" class="headerlink" title="APIC"></a>APIC</h4><p>APIC（Advanced Programmable Interrupt Control）高级可编程中断控制器。有两部分组成：<br>IO APIC：位于南桥中，用于处理桥上的设备所产生的各种中断。它用来接收IO设备所产生的中断，并将其传送给Local APIC。通常有24个输入。<br>Local APIC：位于CPU中，每个CPU都有一个。负责传送中断至指定的处理器。接收来自于CPU interrupt pin,内部中断源、外部IO APIC所产生的中断，并将它们发送到Processor core去处理。在多处理器系统（MP）中，发送和接受system bus上来自其他处理器的IPI message(Inter-Processor Interrupt)。每个Local APIC由一组APIC寄存器和将中断发送到处理器核心以及生成IPI消息的硬件组成。APIC寄存器是内存映射的，可以使用MOV指令读写。</p><p><img src="http://o7iipar59.bkt.clouddn.com/source/2-4.jpg" alt="图3.3 APIC示意图"></p><h3 id="相关内容参考"><a href="#相关内容参考" class="headerlink" title="相关内容参考"></a>相关内容参考</h3><blockquote><p><a href="http://341719xubin.blog.163.com/blog/static/1329207932011925115012605/" target="_blank" rel="noopener">中断原理 - porpoise的日志 - 网易博客</a><br><a href="http://blog.csdn.net/cc_net/article/details/10439665" target="_blank" rel="noopener">计算机原理学习（2）– 存储器和I/O设备和总线 - 念念红尘的技术专栏 - 博客频道 - CSDN.NET</a><br><a href="http://blog.csdn.net/phunxm/article/details/8952963" target="_blank" rel="noopener">中断处理 - 曾梦想仗剑走天涯 - 博客频道 - CSDN.NET</a><br><a href="http://blog.sina.com.cn/s/blog_952b093d0101aj4f.html" target="_blank" rel="noopener">【转】Interrupt - PIC - APIC_pizch_新浪博客</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO相关 </tag>
            
            <tag> MIPS异常与中断 </tag>
            
            <tag> APIC </tag>
            
            <tag> PIC </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写于：梦开始的地方</title>
      <link href="/2016/05/20/First/"/>
      <url>/2016/05/20/First/</url>
      <content type="html"><![CDATA[<p><img src="http://o7iipar59.bkt.clouddn.com/4.jpg" alt="写于梦开始的地方"><br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有写博客的意愿已经有些时间了，本打算在csdn或者是博客园之类的地方进行，但感觉不是自己的地方，弃之。后曾在查资料的时候，在<a href="http://wikidot.com" target="_blank" rel="noopener">wikidot.com</a>网站看到别人用wikidot的域名写博客。但是网页的语法比较复杂，实现起来也不是很美观，遂再弃之。前几天看到使用wordpress做的博客，看起来也不错，但是好看而又免费的模板很少，加之还需要搭建服务器，三弃之。<br>&nbsp;&nbsp;&nbsp;&nbsp;18号，在找资料的途中，看到了一个外观看起来很简约，让我很心动的个人博客网站。然后通过网站上的信息，知乎私信了博主，然后得知了github上Hexo创建博客的方法，经过大约三天的时间，将基本功能外加一定的拓展。并绑定了自己的域名，成为现在这个样子。感觉是真正自己的一片净土。<br>&nbsp;&nbsp;&nbsp;&nbsp;今后，打算在此地，记录些生活和学习相关的事情。来记住不想忘记的事情。</p><h3 id="网站引导"><a href="#网站引导" class="headerlink" title="网站引导"></a>网站引导</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;网站是一个基于hexo进行实现的个人博客。使用github的免费空间进行托管。是一种静态的网页，所以具有加载速度快，安全，稳定的特点。网站的所有动态效果都是基于第三方。基本的功能在前辈们的前赴后继下，已经很完善了。但是由于使用gihub的原因吧，在线更新基本做不到，当然不排除使用vps的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;整个网页分为：首页、分类、归档、标签、留言、个人简介、站外链接等等。主页罗列最近的文章；分类和标签我目前还没有区分出不同的地方；留言页可以对博主留言。支持baidusitemap和google的sitemap，如果后期做的好的话可以搜索到- - 。编辑的话，主要采用markdown语法。这边文章，是第一次使用这种语法来写，如果视觉不是很好，多多包涵。</p><hr><h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo 建站"></a>Hexo 建站</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p> 首先罗列出所有使用到的软件，可以先下一下，来使用：</p><ol><li><a href="https://git-scm.com/download" target="_blank" rel="noopener">Git</a> —编译网站，提交网站</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>—Javascript运行环境</li><li><a href="http://soft.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a>—Markdown编辑器（在编辑器中整体最好，但有些迟缓不过不影响）<br>然后是一些需要注册的网站：</li><li><a href="https://github.com/" target="_blank" rel="noopener">Github</a>—网站托管、网站地址、网站主题和模板获取地址</li><li><a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a>/<a href="http://www.qcloud.com" target="_blank" rel="noopener">腾讯云</a>&amp;/<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpod</a>—前两者是注册域名，学生用户可以去腾讯云1块钱买一台主机和一个cn域名，当然cn域名嘛，你懂的。DNSpod用来做域名解析，来跳转到自己的域名。<br>暂时想到上述这些。下面开始建站。<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3></li><li>首先自行安装完git和node.js这两个软件，并且注册好github。新建一个文件夹如：Hexo存放你的网站。</li><li>桌面打开git bash输入命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」<br>然后系统会要你输入密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br><span class="line">在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</span><br></pre></td></tr></table></figure></p><ol start="3"><li>打开C://Users/lenovo/.ssh/id_rsa.pub使用txt打开，复制里面的内容。到github中右上角：Account Settings—&gt;SSH Public keys —&gt; add another public keys  把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就可以了。</li><li><p>使用下面的命令，来完善信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;cnfeat&quot;//用户名</span><br><span class="line">$ git config --global user.email  &quot;邮件地址@youremail.com&quot;//填写自己的邮箱</span><br></pre></td></tr></table></figure></li><li><p>打开github，点击「New Repository」建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</p></li><li><p>进入Hexo文件夹，右击打开git bash 输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo#安装hexo</span><br><span class="line">$ hexo init#部署</span><br></pre></td></tr></table></figure></li><li><p>之后就会在Hexo文件夹下出现所有的项目，下面的命令经常用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean#清空所有文件</span><br><span class="line">$ hexo generate#生成网站</span><br><span class="line">$ hexo server#本地运行网站，之后可以到localhost:4000预览网站</span><br><span class="line">$ hexo deploy#发布网站，提交到github中</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next  #克隆主题Next主题还是十分推荐的。</span><br><span class="line">一些常用命令：</span><br><span class="line">hexo new&quot;postName&quot; #新建文章</span><br><span class="line">hexo new page&quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure></li><li><p>当我们克隆一个主题后，需要对主题进行配置，进入hexo根目录下的_config.yml找到theme:字段将后面的内容改为next（对于克隆的next主题来说）</p></li><li>对于每个主题来说都有自己的配置方案，具体参考每个主题的自己的配置。这里给出了next主题的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">配置地址</a>。</li><li>网站与域名绑定。网站的解析采用了<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpot</a>进行解析，添加域名—&gt;添加主机记录—&gt;添加两条，<br>一个主机记录是@，类型为CNAME，记录值为your_user_name.github.io；<br>另一个主机记录为www,类型为CNAME，记值为your_user_name.github.io；<br>进入<a href="https://dcc.godaddy.com/dcc50/Default.aspx" target="_blank" rel="noopener">域名提供商</a>(我用的godaddy)的控制台，配置域名服务器为DNSpot的两条记录。<br>此外，还需要到Hexo目录的source文件夹下新建文件CNAME里面的内容只写域名如：southtreer.com；deploy一下，就可以了。<h3 id="建站参考"><a href="#建站参考" class="headerlink" title="建站参考"></a>建站参考</h3>1 <a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="noopener">Hexo在github上构建免费的Web应用 | 粉丝日志</a><br>2 <a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">HEXO+Github,搭建属于自己的博客 - 简书</a><br>3 <a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程 - poem_of_sunshine的专栏 - 博客频道 - CSDN.NET</a><br>4 <a href="http://blog.csdn.net/wave_1102/article/details/41548951" target="_blank" rel="noopener">一步步在GitHub上创建博客主页-最新版 - Wave的专栏 - 博客频道 - CSDN.NET</a><h3 id="配置参考及扩展"><a href="#配置参考及扩展" class="headerlink" title="配置参考及扩展"></a>配置参考及扩展</h3>1 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 使用文档</a><br>2 <a href="http://www.arao.me/" target="_blank" rel="noopener">TypeCho,arao,Hexo,markdown - ARAO’S BLOG - 我们的征途是星辰大海</a></li></ol>]]></content>
      
      <categories>
          
          <category> 学习技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
